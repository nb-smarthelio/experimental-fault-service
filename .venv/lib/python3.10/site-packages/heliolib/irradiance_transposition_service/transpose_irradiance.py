import logging
import numpy as np
import pandas as pd

from pvlib.location import Location
from pvlib.clearsky import ineichen, lookup_linke_turbidity
from pvlib.irradiance import get_extra_radiation, get_total_irradiance


logger = logging.getLogger(__name__)

# Set timezone to UTC as the data comes as UTC time
Timezone = "UTC"


class TransposeIrradiance:
    """
    A class for transposing Global Horizontal Irradiance (GHI) to Plane of Array (POA) Irradiance.

    Parameters
    ----------
    latitude: float
        Latitude of the location in degrees. [-90, 90]
    longitude: float
        Longitude of the location in degrees. [-180, 180]
    altitude: float
        Altitude of the location in meters.
    df: pandas.DataFrame
        DataFrame containing GHI values.

    Methods
    -------
    get_clearsky_ghi()
        Calculate clear sky global horizontal irradiance (GHI) parameters.
    get_clearsky_poa(surface_tilt, surface_azimuth)
        Calculate clear sky plane-of-array (POA) irradiance parameters.
    utc_transposition_model(surface_tilt, surface_azimuth)
        Transposes GHI to POA based on tilt and azimuth angles.

    Raises
    ------
    ValueError
        If the latitude is not between -90 and 90 degrees.
        If the longitude is not between -180 and 180 degrees.
        If the surface tilt is not between 0 and 90 degrees.
        If the surface azimuth is not between 0 and 359 degrees.
        If the DataFrame index is not set to UTC timezone.
    """

    def __init__(
        self, latitude: float, longitude: float, altitude: float, df: pd.DataFrame
    ) -> None:

        logger.warning("This assumes that the input data is in UTC timezone.")
        # Validate latitude and longitude
        if not (-90 <= latitude <= 90):
            raise ValueError(
                "Invalid latitude. Latitude must be between -90 and 90 degrees."
            )

        if not (-180 <= longitude <= 180):
            raise ValueError(
                "Invalid longitude. Longitude must be between -180 and 180 degrees."
            )

        self.lat = latitude
        self.long = longitude
        self.alt = altitude
        self.df = df
        self.site_location = self._get_site_location()
        self.solar_position = self._get_solar_position()
        self.airmass = self._get_airmass()
        self.linked_turbidity = self._get_linked_turbidity()
        self.extra_radiation = self._get_extra_radiation()

    @staticmethod
    def _validate_input_variables(surface_tilt: float, surface_azimuth: float) -> None:
        if not (0 <= surface_tilt <= 90):
            raise ValueError(
                "Invalid Surface-Tilt. Surface-Tilt must be between 0 and 90 degrees."
            )

        if not (0 <= surface_azimuth <= 359):
            raise ValueError(
                "Invalid Surface-Azimuth. Surface-Azimuth must be between 0 and 359 degrees."
            )

    def _get_site_location(self) -> Location:
        """
        Retrieve location details using latitude, longitude, altitude, and timezone.

        Returns:
        --------
        site_location: pvlib.Location
            Location object containing site
        """
        site_location = Location(
            latitude=self.lat, longitude=self.long, altitude=self.alt, tz=Timezone
        )
        logger.debug("Clearsky Modelling: Extracted Site Location.")

        return site_location

    def _get_solar_position(self):
        """
        Calculate solar position parameters based on times.
        """
        solar_position = self.site_location.get_solarposition(times=self.df.index)
        logger.debug("Clearsky Modelling: Extracted Solar Position.")

        return solar_position

    def _get_airmass(self) -> pd.DataFrame:
        """
        Calculate airmass values based on solar position and times.

        Returns:
        --------
        airmass: pandas.DataFrame
            Series containing airmass values for each time.
        """
        airmass = self.site_location.get_airmass(
            times=self.df.index, solar_position=self.solar_position
        )
        logger.debug("Clearsky Modelling: Extracted Airmass.")
        return airmass

    def _get_linked_turbidity(self) -> pd.Series:
        """
        Lookup Linked turbidity values based on location and times.

        Returns:
        --------
        linked_turbidity: pandas.Series
            Series containing linked turbidity values for each time.
        """
        linked_turbidity = lookup_linke_turbidity(
            time=self.df.index, latitude=self.lat, longitude=self.long
        )
        logger.debug("Clearsky Modelling: Extracted Linked Turbidity.")
        return linked_turbidity

    def _get_extra_radiation(self) -> pd.Series:
        """
        Get extra radiation values based on times.

        Returns:
        --------
        extra_radiation: pandas.Series
            Series containing extra radiation values for each time.
        """
        extra_radiation = get_extra_radiation(datetime_or_doy=self.df.index)
        logger.debug("Clearsky Modelling: Extracted Extra Radiation.")
        return extra_radiation

    def get_clearsky_ghi(self) -> pd.DataFrame:
        """
        Calculate clear sky global horizontal irradiance (GHI) parameters.

        Returns:
        --------
        ghi_clearsky_parameters: pandas.DataFrame
            DataFrame containing clear sky GHI parameters for each time.
        """
        # Calculate clear sky GHI based on solar position, airmass, turbidity, etc.
        ghi_clearsky_parameters = ineichen(
            apparent_zenith=self.solar_position["apparent_zenith"],
            airmass_absolute=self.airmass["airmass_absolute"],
            linke_turbidity=self.linked_turbidity,
            altitude=self.alt,
            dni_extra=self.extra_radiation,
        )
        return ghi_clearsky_parameters

    def get_clearsky_poa(
        self, surface_tilt: float, surface_azimuth: float
    ) -> pd.DataFrame:
        """
        Calculate clear sky plane-of-array (POA) irradiance parameters.

        Parameters:
        ----------
        surface_tilt: float
            Tilt angle of the solar panel surface.
        surface_azimuth: float
            Azimuth angle of the solar panel surface.

        Returns:
        -------
        poa_clearsky_parameters: pandas.DataFrame
            DataFrame containing clear sky POA parameters for each time.
        """

        ghi_clearsky_parameters = self.get_clearsky_ghi()

        # Calculate clear sky POA based on surface tilt, azimuth, GHI, DNI, DHI, etc.
        poa_clearsky_parameters = get_total_irradiance(
            surface_tilt=surface_tilt,
            surface_azimuth=surface_azimuth,
            dni=ghi_clearsky_parameters["dni"],
            ghi=ghi_clearsky_parameters["ghi"],
            dhi=ghi_clearsky_parameters["dhi"],
            solar_zenith=self.solar_position["apparent_zenith"],
            solar_azimuth=self.solar_position["azimuth"],
        )

        return poa_clearsky_parameters

    def utc_transposition_model(
        self, surface_tilt: float, surface_azimuth: float
    ) -> pd.DataFrame:
        """
        Transposes GHI (Global Horizontal Irradiance) to POA (Plane of Array Irradiance).

        Parameters:
        ----------
        surface_tilt: float
            Tilt angle of the solar panel surface.
        surface_azimuth: float
            Azimuth angle of the solar panel surface.

        Returns:
        --------
        pandas.DataFrame
            DataFrame containing transposed POA values.
        """

        self._validate_input_variables(surface_tilt, surface_azimuth)

        # Check if the DataFrame index is set to UTC timezone
        if str(self.df.index.tz) != "UTC":
            raise ValueError(
                "The DataFrame must have a timezone aware index set to UTC."
            )

        # Convert tilt and azimuth angles to radians
        tilt_radian = np.deg2rad(surface_tilt)
        azimuth_radian = np.deg2rad(surface_azimuth)

        # Name of the column for GHI
        column_name = "GHI"

        # Check if the GHI column is present in the DataFrame
        if column_name not in self.df.columns:
            raise ValueError(f"'{column_name}' must be in the DataFrame.")

        # Retrieve clear sky GHI and POA parameters
        clearsky = self.get_clearsky_ghi()
        clearsky_POA = self.get_clearsky_poa(surface_tilt, surface_azimuth)

        # Calculate normalized values and intermediate POA values
        self.df["GHI_norm"] = self.df["GHI"] / self.df["GHI"].max()
        self.df["csky_GHI"] = clearsky["ghi"].copy()
        self.df["csky_GHI_norm"] = self.df["csky_GHI"] / self.df["csky_GHI"].max()
        self.df["csky_POA"] = clearsky_POA["poa_global"].copy()
        self.df["csky_POA_norm"] = self.df["csky_POA"] / self.df["csky_POA"].max()
        self.df["POA_inter"] = (
            self.df["csky_POA_norm"] / self.df["csky_GHI_norm"]
        ) * self.df["GHI_norm"]
        self.df["POA_inter_norm"] = self.df["POA_inter"] / self.df["POA_inter"].max()

        apparent_zenith = self.solar_position["apparent_zenith"]
        azimuth = self.solar_position["azimuth"]

        # Calculate dot product and zenith angle at maximum GHI
        Sun_Zenith_radian = np.deg2rad(
            apparent_zenith.loc[self.df["csky_POA"].idxmax()]
        )

        Sun_Azimuth_radian = np.deg2rad(azimuth.loc[self.df["csky_POA"].idxmax()])

        x_zenith = np.sin(Sun_Zenith_radian) * np.cos(Sun_Azimuth_radian - np.pi / 2)
        y_zenith = np.sin(Sun_Zenith_radian) * np.sin(Sun_Azimuth_radian - np.pi / 2)
        z_zenith = np.cos(Sun_Zenith_radian)
        x_normal = np.sin(tilt_radian) * np.cos(azimuth_radian - np.pi / 2)
        y_normal = np.sin(tilt_radian) * np.sin(azimuth_radian - np.pi / 2)
        z_normal = np.cos(tilt_radian)

        # Calculate dot product of zenith and normal angles
        dot_product = x_zenith * x_normal + y_zenith * y_normal + z_zenith * z_normal

        # Calculate zenith angle at maximum GHI
        zenith_at_GHI_max = np.deg2rad(apparent_zenith.loc[self.df["GHI"].idxmax()])

        # Calculate the transposed POA values and store in the DataFrame
        self.df["Gpoa"] = (
            self.df["POA_inter_norm"]
            * dot_product
            * self.df["GHI"].max()
            / np.cos(zenith_at_GHI_max)
        )

        return self.df
