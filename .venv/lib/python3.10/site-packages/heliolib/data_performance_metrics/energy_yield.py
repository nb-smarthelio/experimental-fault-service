import logging
import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)

POWER_KEY = "P"


class EnergyYield:
    """
    Calculates instantaneous, daily, total and specific energy yield from power data and array information.

    Attributes
    ----------
        input_data (pd.DataFrame): Input data containing power values with a DatetimeIndex.
        array_info (pd.DataFrame): Information about the solar array, including installed capacity.
        power_key (str): Column name of the power values in the input_data. Default is "P".

    Methods
    -------
        - calculate_instantaneous_energy_yield(): Get the instantaneous energy yield.
        - calculate_daily_energy_yield(): Get the daily energy yield.
        - calculate_total_energy_yield(): Get the total energy yield.
        - calculate_specific_energy_yield(): Get the specific energy yield.
    """

    def __init__(self, input_data, array_info, power_key=POWER_KEY):
        self.input_data = input_data
        self.array_info = array_info
        self.power_key = power_key
        self._validate_all_required_keys_are_present_in_input_data()
        self._validate_array_info()
        self._calculate_data_frequency()
        self.instantaneous_energy = self.calculate_instantaneous_energy_yield()

    def _validate_all_required_keys_are_present_in_input_data(self):
        """
        Validate if all required keys are present in the input data.

        Raises
        ------
            ValueError: If the index of the input data is not a DatetimeIndex.
            KeyError: If power (P) data is unavailable in the input data.
        """

        curve_level = self.input_data.columns.get_level_values(level="curve")

        if not isinstance(self.input_data.index, pd.DatetimeIndex):
            raise TypeError(f"The index of the input data must be a DatetimeIndex.")

        if self.power_key not in curve_level:
            raise KeyError(f"Power {self.power_key} data is unavailable in input data.")

    def _validate_array_info(self):
        """
        Validate the array information.

        Raises
        ------
            ValueError: If the number of keys in array_info does not match the number of columns in the input data,
                        or if the values in array_info.installed_capacity are either nan or 0.
        """
        logger.info(
            "EnergyYield: Please ensure that both installed capacity and power values are in the same unit."
        )
        # same keys as input data
        if len(self.array_info) != len(
            self.input_data.xs(f"{self.power_key}", level="curve", axis=1).columns
        ):
            raise ValueError(
                f"The number of keys in the array_info does not match the number of columns in the input_data."
            )
        # non nan values/0 in installed capacity
        if (np.isnan(self.array_info.installed_capacity).any()) or (
            self.array_info.installed_capacity.values == 0
        ).any():
            raise ValueError(
                f"The values in the array_info.installed_capacity are either nan or 0."
            )

    def _calculate_data_frequency(self):
        """
        calculate the data frequency.

        """
        self.data_frequency = int(
            np.median(np.diff(self.input_data.index.values)) / 1e9 / 60
        )
        logger.info(
            f"EnergyYield: The data frequency is found to be {self.data_frequency} min when calculating Energy Yield."
        )

    def calculate_instantaneous_energy_yield(self):
        """
        Calculate instantaneous energy yield.

        Returns
        -------
            pd.Series: A Series containing the calculated instantaneous energy yield.
        """

        power = self.input_data.xs(self.power_key, axis=1, level="curve")
        logger.info(f"EnergyYield: Filtering for power values above 0.")
        power = power[power > 0]

        # converting freq min into freq hour
        step = self.data_frequency / 60
        power_resampled = power.resample(str(self.data_frequency) + "min").mean()

        # Calculate the energy generated for each row
        # [formula: 1/2 * (Power_i + Power_i+1) * step]
        output_energy = (
            (power_resampled + power_resampled.shift(periods=-1, fill_value=np.nan))
            * step
            * (1 / 2)
        )

        return output_energy

    def calculate_daily_energy_yield(self):
        """
        Get the daily energy yield.

        Returns
        -------
            pd.Series: A Series containing the daily energy yield.
        """

        daily_yield = self.instantaneous_energy.groupby(pd.Grouper(freq="D")).sum()

        return daily_yield

    def calculate_total_energy_yield(self):
        """
        Get the total energy yield.

        Returns
        -------
            pd.Series: A Series containing the total energy yield.
        """

        daily_yield = self.instantaneous_energy.groupby(pd.Grouper(freq="D")).sum()
        total_yield = daily_yield.sum(axis=0, skipna=True)

        return total_yield

    def calculate_specific_energy_yield(self):
        """
        Get the specific energy yield.

        Returns
        -------
            pd.Series: A Series containing the specific energy yield.
        """

        daily_yield = self.instantaneous_energy.groupby(pd.Grouper(freq="D")).sum()
        spec_daily_yield = daily_yield / self.array_info["installed_capacity"]

        return spec_daily_yield
