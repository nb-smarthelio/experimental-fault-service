from typing import Union

import numpy as np
from pandas import Series

import logging as logger


def calculate_energy_from_power(
    power_series: Series,
    freq: Union[int, float],
    time_conversion_factor: Union[int, float] = 60,
    shift_index: int = 1,
) -> Series:
    """
    Calculate the energy from a power series using the trapezoidal rule for numerical integration.

    The function calculates the energy from a power series using the trapezoidal rule for numerical integration.
    The function takes two parameters: power_series and freq.
    power_series is a pandas Series object that represents power values.
    freq is the frequency of the power data in minutes.
    The function first calculates the step size by dividing the frequency by 60 to convert it to hours.
    Next, it calculates the energy series by adding the power series to a shifted version of itself (shifted by one place), multiplying by the step size, and then dividing by 2.
    The shift operation with a fill value of np.nan ensures that the first value of the power series, which does not have a previous value to pair with, is not included in the calculation.
    Finally, the function returns the energy series.

    Parameters
    ----------
    power_series : pandas.Series
        A series object that represents power values.
    freq : int or float
        The frequency of the power data in minutes.
    time_conversion_factor: int or float
        Time conversion factor. Default value is 60 to convert minutes to hours.
    shift_index: int
        Factor to shift index by desired number of periods. Default value is 1.

    Returns
    -------
    pandas.Series
        A series object that represents the energy calculated from the power series.

    """
    if not isinstance(power_series, Series):
        raise TypeError("power_series must be a pandas Series")
    if not isinstance(freq, (int, float)):
        raise TypeError("freq must be an integer or float")
    if freq <= 0:
        raise ValueError("freq must be greater than 0")
    if power_series.isnull().any():
        raise ValueError("power_series contains NaN values")
    if len(power_series.dropna()) < 2:
        raise ValueError("power_series contains less than 2 non-NaN values")

    step = freq / time_conversion_factor
    logger.debug(f"Step size (hours): {step}")
    energy_series = (
        (power_series + power_series.shift(shift_index, fill_value=np.nan)) * step * 0.5
    )
    return energy_series
