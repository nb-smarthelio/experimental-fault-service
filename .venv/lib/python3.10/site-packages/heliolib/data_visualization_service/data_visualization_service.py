import pandas as pd
import plotly.graph_objects as go
from plotly.subplots import make_subplots


class Plot:
    """
    Base Plot class for handling common plot functionalities.
    """

    def __init__(self, inverter_data, meteo_data):
        self.inverter_data = inverter_data
        self.meteo_data = meteo_data

    def _get_data_source(self, col):
        """
        Get the data source based on the given column.
        """
        if col == "G":
            return self.meteo_data
        else:
            return self.inverter_data

    def _filter_data(self, col, ag_level_2=None, ag_level_1=None):
        """
        Filters the data based on the given column and optional aggregation levels.
        """
        data = self._get_data_source(col)
        if ag_level_2:
            data = data.xs(key=ag_level_2, level="ag_level_2", axis=1)
        if ag_level_1:
            data = data.xs(key=ag_level_1, level="ag_level_1", axis=1)
        return data[col]

    def _aggregate_data(self, col, agg_type, ag_level_2=None, ag_level_1=None):
        """
        Aggregates the data based on the specified column, aggregation type, and optional levels.
        """
        data = self._filter_data(col, ag_level_2, ag_level_1)
        if agg_type == "day":
            return data.resample("D")
        elif agg_type == "hour":
            return data.resample("H")

    def plot(
        self,
        columns,
        date_range=None,
        agg_period="day",
        ag_level_2=None,
        ag_level_1=None,
    ):
        """
        Abstract method to be overridden in subclasses.
        """
        raise NotImplementedError

    # ------------ Plotting Methods ------------ #


class LinePlot(Plot):
    """
    Class to handle line plots.
    """

    def _create_trace_group(self, base_col):
        """
        Helper function to create a trace group for the given base column.
        It will include the base column, its STC or NOCT counterpart if present, and irradiance 'G' if applicable.
        """
        trace_group = [base_col]
        if f"{base_col}_exp_stc" in self.inverter_data.columns.get_level_values(
            "curve"
        ):
            trace_group.append(f"{base_col}_exp_stc")
        elif f"{base_col}_exp_noct" in self.inverter_data.columns.get_level_values(
            "curve"
        ):
            trace_group.append(f"{base_col}_exp_noct")
        # Append 'G' if it's supposed to be with the base column and it's in the columns list
        if base_col in ["I", "P"] and "G" in self.meteo_data.columns.get_level_values(
            level="curve"
        ):
            trace_group.append("G")
        return trace_group

    def plot(
        self,
        columns,
        date_range=None,
        agg_period="day",
        ag_level_2=None,
        ag_level_1=None,
    ):
        column_name_map = {
            "P": "Power",
            "G": "Irradiance",
            "I": "Current",
            "V": "Voltage",
            "P_exp_stc": "Expected Power (STC)",
            "I_exp_stc": "Expected Current (STC)",
            "V_exp_stc": "Expected Voltage (STC)",
            "P_exp_noct": "Expected Power (NOCT)",
            "I_exp_noct": "Expected Current (NOCT)",
            "V_exp_noct": "Expected Voltage (NOCT)",
        }

        def should_use_secondary_y_axis(col):
            return col in [
                "G"
            ]  # , "P_exp_stc", "I_exp_stc", "P_exp_noct", "I_exp_noct"]

        def add_trace_to_plot(data, col_name, subplot_idx, secondary_y=False):
            fig.add_trace(
                go.Scatter(
                    x=data.index,
                    y=data.values,
                    mode="lines",
                    name=column_name_map.get(col_name, col_name),
                ),
                row=subplot_idx,
                col=1,
                secondary_y=secondary_y,
            )

        # Define the subplot structure based on the provided columns
        subplot_structure = []
        subplot_titles = []

        # Create trace groups for I, P, and V if present
        for param in ["I", "P", "V"]:
            if (
                param in columns
                or f"{param}_exp_stc" in columns
                or f"{param}_exp_noct" in columns
            ):
                trace_group = self._create_trace_group(param)
                subplot_structure.append(trace_group)
                title_suffix = " and Irradiance" if "G" in trace_group else ""
                subplot_titles.append(
                    f"{param}{' Expected' if '_exp_' in trace_group[1] else ''}{title_suffix}"
                )

        # Corrected subplot_specs
        subplot_specs = [
            [{"secondary_y": any(should_use_secondary_y_axis(col) for col in group)}]
            for group in subplot_structure
        ]
        num_rows = len(subplot_structure)
        # Create the figure with corrected subplot_specs
        fig = make_subplots(
            rows=num_rows,
            cols=1,
            shared_xaxes=True,
            subplot_titles=subplot_titles,
            vertical_spacing=0.1,
            specs=subplot_specs,
        )

        subplot_idx = 1
        for group in subplot_structure:
            for col in group:
                if col in columns or any(
                    col.startswith(prefix)
                    for prefix in ["I", "V", "P"]
                    for col in columns
                ):
                    data = self._filter_data(col, ag_level_2, ag_level_1)
                    add_trace_to_plot(
                        data,
                        col,
                        subplot_idx,
                        secondary_y=should_use_secondary_y_axis(col),
                    )

            subplot_idx += 1  # Increment subplot index for the next group

        # Update layout
        fig.update_layout(
            title_text=f"Combined plots for {', '.join(columns)} (ag_level_2={ag_level_2}, ag_level_1={ag_level_1})"
        )
        fig.update_layout(
            annotations=[
                go.layout.Annotation(
                    text="SmartHelio",
                    showarrow=False,
                    xref="paper",
                    yref="paper",
                    x=1.1,
                    y=-0.1,
                    xanchor="right",
                    yanchor="bottom",
                    opacity=0.5,
                    font=dict(family="Montserrat, sans-serif", color="orange", size=20),
                )
            ]
        )
        fig.update_layout(font=dict(family="Montserrat, sans-serif"))
        xaxis_attr = f"xaxis{num_rows}_rangeslider_visible"
        xaxis_thickness_attr = f"xaxis{num_rows}_rangeslider_thickness"
        fig.update_layout({xaxis_attr: True, xaxis_thickness_attr: 0.05})

        fig.show()


class BarPlot(Plot):
    """
    Class to handle bar plots.
    """

    def plot(
        self,
        columns,
        date_range=None,
        agg_period="day",
        ag_level_2=None,
        ag_level_1=None,
    ):
        for col in columns:
            data = self._aggregate_data(col, agg_period, ag_level_2, ag_level_1)
            if col == "P":
                data = data.sum()
            else:
                data = data.mean()

            fig = go.Figure(data=[go.Bar(x=data.index, y=data.values, hoverinfo="x+y")])

            if col == "P":
                y_axis_title = "Power (W)"
            elif col == "G":
                y_axis_title = "Irradiance (W/m^2)"
            elif col == "I":
                y_axis_title = "Current (A)"
            elif col == "V":
                y_axis_title = "Voltage (V)"
            else:
                y_axis_title = "Value"

            fig.update_layout(
                title_text=f"Bar plot for {col} (Aggregated by {agg_period}, ag_level_2={ag_level_2}, ag_level_1={ag_level_1})",
                yaxis_title=y_axis_title,
            )
            fig.show()


class HeatmapPlot(Plot):
    """
    Class to handle heatmap plots.
    """

    def plot(
        self,
        columns,
        date_range=None,
        agg_period="day",
        ag_level_2=None,
        ag_level_1=None,
    ):
        for col in columns:
            data = self._filter_data(col, ag_level_2, ag_level_1)
            data_df = data.to_frame()
            data_df["Time"] = [time.time() for time in data_df.index]
            data_df.index = pd.to_datetime(data_df.index)
            data_pivot = data_df.pivot_table(
                index=data_df.index.date,
                columns="Time",
                values=col,
            )

            fig = go.Figure(
                data=go.Heatmap(
                    z=data_pivot.values,
                    x=data_pivot.columns,
                    y=data_pivot.index,
                    colorscale="Viridis",
                )
            )
            fig.update_layout(
                title_text=f"Heatmap for {col} (ag_level_2={ag_level_2}, ag_level_1={ag_level_1})",
                xaxis_nticks=24,
            )
            fig.show()


class CorrelationPlot(Plot):
    """
    Class to handle correlation plots.
    """

    def plot(
        self,
        columns,
        date_range=None,
        agg_period="day",
        ag_level_2=None,
        ag_level_1=None,
    ):
        if len(columns) != 2:
            raise ValueError(
                "For correlation plot, exactly two columns should be provided."
            )

        col1, col2 = columns

        data1 = self._filter_data(col1, ag_level_2, ag_level_1)
        data2 = self._filter_data(col2, ag_level_2, ag_level_1)
        color_data = self._filter_data("G", ag_level_2, ag_level_1)
        # Get the common indices
        common_indices = data1.index.intersection(color_data.index)

        # Filter the data to the common indices
        data1 = data1.loc[common_indices]
        data2 = data2.loc[common_indices]
        color_data = color_data.loc[common_indices]

        # Determine the range for the slider based on actual G values
        g_min = int(color_data.min())
        g_max = int(color_data.max())
        g_step = 50  # or any other desired step value
        g_ranges = list(range(g_min, g_max + g_step, g_step))
        masks = [
            (color_data >= g_ranges[i]) & (color_data <= g_ranges[i + 1])
            for i in range(len(g_ranges) - 1)
        ]

        traces = []
        for mask in masks:
            trace = go.Scatter(
                x=data1[mask],
                y=data2[mask],
                mode="markers",
                marker=dict(
                    size=5,
                    color=color_data[mask],
                    colorscale="Viridis",
                    cmin=color_data.min(),  # set cmin to the minimum G value of all points
                    cmax=color_data.max(),  # set cmax to the maximum G value of all points
                    colorbar=dict(title="Irradiance (G)"),
                ),
                text=color_data[mask],
                visible=True,
                showlegend=False,
            )
            traces.append(trace)

        steps = []
        for i in range(len(g_ranges) - 1):
            step = dict(
                args=["visible", [False] * len(traces)],
                method="restyle",
                label=f"{g_ranges[i]} to {g_ranges[i+1]}",
            )
            step["args"][1][i] = True  # Toggle i'th trace to "visible"
            steps.append(step)

        sliders = [
            dict(
                active=0,
                yanchor="top",
                xanchor="left",
                currentvalue={
                    "font": {"size": 20},
                    "prefix": "G range:",
                    "visible": True,
                    "xanchor": "right",
                },
                pad={"b": 10, "t": 50},
                len=0.9,
                x=0.1,
                y=0,
                steps=steps,
            )
        ]
        # Add a button to reset the view to all points
        buttons = [
            dict(
                args=[{"visible": [True] * len(traces)}],
                label="Reset View",
                method="restyle",
            )
        ]
        updatemenus = [
            dict(
                type="buttons",
                direction="right",
                x=0.57,
                y=1.2,
                buttons=buttons,
            )
        ]

        layout = go.Layout(
            title_text=f"Correlation between {col1} and {col2} colored by G (ag_level_2={ag_level_2}, ag_level_1={ag_level_1})",
            xaxis_title=col1,
            yaxis_title=col2,
            sliders=sliders,
            updatemenus=updatemenus,  # Add the updatemenus to the layout
        )

        fig = go.Figure(data=traces, layout=layout)
        # Display only the first trace initially
        fig.data[0].visible = True

        fig.show()


# Main DataVisualisation class:


class DataVisualisation:
    """
    A class for visualizing inverter and meteorological data using various plot types.
    """

    def __init__(self, inverter_data, meteo_data):
        self.inverter_data = inverter_data
        self.meteo_data = meteo_data

    def plot(
        self,
        columns,
        plot_type,
        date_range=None,
        agg_period="day",
        ag_level_2=None,
        ag_level_1=None,
    ):
        """
        Plots the specified columns of data with the given plot type and other options.
        """
        # Data Filtering by Date Range
        if date_range:
            start_date, end_date = date_range
            self.inverter_data = self.inverter_data.loc[start_date:end_date]
            self.meteo_data = self.meteo_data.loc[start_date:end_date]

        if ag_level_2:
            unique_ag2_values = [ag_level_2]
        else:
            unique_ag2_values = self.inverter_data.columns.get_level_values(
                "ag_level_2"
            ).unique()
        for ag2 in unique_ag2_values:
            # Filter the ag_level_1 values that are associated with the current ag_level_2
            if ag_level_1:
                filtered_ag1_values = [ag_level_1]
            else:
                filtered_ag1_values = (
                    self.inverter_data.xs(key=ag2, level="ag_level_2", axis=1)
                    .columns.get_level_values("ag_level_1")
                    .unique()
                )
            for ag1 in filtered_ag1_values:
                # Mapping plot types to their respective classes.
                plot_class_mapping = {
                    "line": LinePlot,
                    "bar": BarPlot,
                    "heatmap": HeatmapPlot,
                    "correlation": CorrelationPlot,
                }

                plot_class = plot_class_mapping.get(plot_type)
                if not plot_class:
                    raise ValueError(f"Unsupported plot type: {plot_type}")

                plotter = plot_class(self.inverter_data, self.meteo_data)

                # Delegate the actual plotting to the relevant class
                plotter.plot(columns, date_range, agg_period, ag2, ag1)


# Usage:

# Assuming df_inverter and df_meteo are your loaded dataframes:
# vis = DataVisualisation(df_inverter, df_meteo)
# vis.plot(columns=['P', 'G', 'I', 'V'], plot_type='bar', date_range=('2023-01-01', '2023-01-15'), agg_period='hour')
# vis.plot(columns=['P', 'G'], plot_type='heatmap')
# vis.plot(columns=['P', 'I', 'V', 'G'], plot_type='line')
# vis.plot(columns=['I', 'V'], plot_type='correlation')
