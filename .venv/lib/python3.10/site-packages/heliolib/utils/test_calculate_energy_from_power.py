import pytest
import pandas as pd
import numpy as np
from .calculate_energy_from_power import (
    calculate_energy_from_power,
)
import logging


def test_calculate_energy_from_power_normal():
    power_series = pd.Series([100.0, 200.0, 400.0])
    freq = 30
    expected_energy_series = pd.Series([np.nan, 75.0, 150.0])

    energy_series = calculate_energy_from_power(power_series, freq)
    pd.testing.assert_series_equal(energy_series, expected_energy_series)


def test_calculate_energy_from_power_series_not_a_series():
    power_series = [100, 50, 25]
    freq = 10
    with pytest.raises(TypeError) as e:
        calculate_energy_from_power(power_series, freq)
    assert str(e.value) == "power_series must be a pandas Series"


def test_calculate_energy_from_power_non_numeric_freq():
    power_series = pd.Series([100.0, 50.0, 25.0])
    freq = "not_a_number"

    with pytest.raises(TypeError) as e:
        calculate_energy_from_power(power_series, freq)
    assert str(e.value) == "freq must be an integer or float"


def test_calculate_energy_from_power_non_positive_freq():
    power_series = pd.Series([100.0, 50.0, 25.0])
    freq = 0

    with pytest.raises(ValueError) as e:
        calculate_energy_from_power(power_series, freq)
    assert str(e.value) == "freq must be greater than 0"


def test_calculate_energy_from_power_with_one_nan_value(caplog):
    power_series = pd.Series([100.0, 50.0, np.nan, 25.0])
    freq = 1.0
    expected_energy_series = pd.Series([np.nan, 1.25, np.nan, np.nan])
    with caplog.at_level(logging.WARNING):
        energy_series = calculate_energy_from_power(power_series, freq)
    # Check that a warning was logged
    assert "power_series contains NaN values" in caplog.text

    pd.testing.assert_series_equal(energy_series, expected_energy_series)


def test_calculate_energy_from_power_with_all_nan_power_values(caplog):
    power_series = pd.Series([np.nan, np.nan, np.nan, np.nan])
    freq = 1.0
    expected_energy_series = pd.Series([np.nan, np.nan, np.nan, np.nan])
    with caplog.at_level(logging.WARNING):
        energy_series = calculate_energy_from_power(power_series, freq)
    # Check that a warning was logged
    assert "power_series contains NaN values" in caplog.text

    pd.testing.assert_series_equal(energy_series, expected_energy_series)


def test_calculate_energy_from_power_with_empty_power_series():
    power_series = pd.Series([])
    freq = 10

    # expected energy_series should be empty ( 1st value will not be nan because when empty, shift is not called)
    expected_energy_series = pd.Series([])

    energy_series = calculate_energy_from_power(power_series, freq)

    pd.testing.assert_series_equal(energy_series, expected_energy_series)


def test_calculate_energy_from_power_with_one_normal_power_value(caplog):
    # power series contains all nan values but 1
    power_series = pd.Series([5.0, np.nan, np.nan, np.nan])
    freq = 1.0
    expected_energy_series = pd.Series([np.nan, np.nan, np.nan, np.nan])
    with caplog.at_level(logging.WARNING):
        energy_series = calculate_energy_from_power(power_series, freq)
    # Check that a warning was logged
    assert "power_series contains NaN values" in caplog.text

    pd.testing.assert_series_equal(energy_series, expected_energy_series)
