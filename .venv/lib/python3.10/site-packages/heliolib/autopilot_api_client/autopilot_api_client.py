import json
import logging
import pandas as pd
from datetime import datetime

logger = logging.getLogger(__name__)


class AutopilotAPIClient:
    """
    A client for managing and persisting fault and KPI data via an API in an automation system.

    This client class is designed to interact with an API, providing functionalities to validate
    and send fault and key performance indicator (KPI) data to a specified API endpoint. It ensures
    the integrity of the data before transmission and utilizes a retry mechanism for robust API interactions.

    Attributes
    ----------
    url : str
        The URL of the Autopilot API endpoint.
    api_retry_session : <Type>
        An object or function that manages API requests with retry logic. The exact type should be specified.

    Methods
    -------
    persist_fault_in_database(fault_data: pd.DataFrame):
        Validates and sends fault data to the API to be stored in the database.
    persist_kpi_in_db(kpi_results_json: json):
        Sends KPI data to the API for storage in the database.
    """

    def __init__(self, url: str, api_retry_session):
        self.url = url
        self.api_retry_session = api_retry_session
        """
        Initializes the AutopilotAPIClient with the API URL and a retry session handler.

        Parameters
        ----------
        url : str
            The URL endpoint for the Autopilot API.
        api_retry_session : <Type>
            A session handler with retry logic for making API requests. The specific type should be described.
        """

    @staticmethod
    def _validate_fault_data(fault_data: pd.DataFrame) -> None:
        """
        Validates the format and content of the provided fault_data DataFrame.

        Ensures that fault_data is a Pandas DataFrame with specific columns ('plant_id', 'fault_id',
        'fault_name', 'inverter_id') containing string values. Raises exceptions if the validation fails.

        Parameters
        ----------
        fault_data : pd.DataFrame
            DataFrame containing fault data to be validated.

        Raises
        ------
        TypeError
            If fault_data is not a DataFrame or if required columns are of incorrect type.
        KeyError
            If required columns are missing in the DataFrame.
        """

        if not isinstance(fault_data, pd.DataFrame):
            raise TypeError(f"Parameter fault_dataframe must be a pd.DataFrame")

        if "plant_id" in fault_data.columns:
            if not isinstance(fault_data["plant_id"][0], str):
                raise TypeError(f'Parameter "plant_id" must be a string')
        else:
            raise KeyError(f'Parameter "plant_id" must be a provided')

        if "fault_name" in fault_data.columns:
            if not isinstance(fault_data["fault_name"][0], str):
                raise TypeError(f'Parameter "fault_name" must be a string')
        else:
            raise KeyError(f'Parameter "fault_name" must be a provided')

        if "inverter_id" in fault_data.columns:
            if not isinstance(fault_data["inverter_id"][0], str):
                raise TypeError(f'Parameter "inverter_id" must be a string')
        else:
            raise KeyError(f'Parameter "inverter_id" must be a provided')

    def persist_fault_in_database(self, fault_data: pd.DataFrame) -> None:
        """
        Validates and sends fault data to the API for storage in the database.

        Each record in the fault_data DataFrame is sent as a separate POST request after adding an
        'updated_at' timestamp. Uses the api_retry_session for handling POST requests.

        Parameters
        ----------
        fault_data : pd.DataFrame
            DataFrame containing fault data to be persisted.

        Notes
        -----
        Logs the success or failure of data transmission to the API.
        """

        self._validate_fault_data(fault_data)

        fault_data["updated_at"] = datetime.now().isoformat()
        posts = json.loads(fault_data.to_json(orient="records", date_format="iso"))

        response = self.api_retry_session.post(
            self.url,
            data=json.dumps(posts[0]),
            headers={"Content-Type": "application/json"},
        )

        if response.status_code == 200:
            logger.info(f"Successfully sent fault data to the API")
        else:
            logger.error(f"Failed to send fault data to the API")

    def persist_kpi_in_db(self, kpi_results_json: json) -> None:
        """
        Sends KPI data to the API for storage in the database.

        Processes each element in the provided JSON array as a separate record, excluding those with
        'inverter_id' equal to 'plant'. Uses the api_retry_session for making POST requests.

        Parameters
        ----------
        kpi_results_json : json
            JSON array containing KPI data.

        Notes
        -----
        Logs the number of records that were not successfully ingested.
        """

        count = 0
        for row in kpi_results_json:
            if row["inverter_id"] == "plant":
                pass
            else:
                response = self.api_retry_session.post(
                    self.url,
                    data=json.dumps(row),
                    headers={"Content-Type": "application/json"},
                )
                if response.status_code != 200:
                    print(response.json())
                    count += 1
        logger.info("{} records were not ingested.".format(count))
