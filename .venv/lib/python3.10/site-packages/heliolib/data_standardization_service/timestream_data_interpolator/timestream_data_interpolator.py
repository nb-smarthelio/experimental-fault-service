import logging
import warnings
from abc import ABC, abstractmethod
from datetime import datetime

import numpy as np
import pandas as pd
from astral import LocationInfo
from heliolib.solar_tools import SunTimes
from heliolib.utils import calculate_frequency_in_integer_minutes
from ..validation import ValidationExecutor

logger = logging.getLogger(__name__)


class Interpolator(ABC):
    """
    An abstract base class for interpolating missing values in a pandas DataFrame.

    The Interpolator class provides a framework for various interpolation methods, handling NaN values,
    and warning the user if the fraction of excluded data exceeds a certain threshold.

    Subclasses should implement the run_interpolator method with specific interpolation strategies.

    Parameters:
    -----------
    interpolation_method : str
        The interpolation method to use.
    max_consecutive_nans_duration : pd.Timedelta
        The maximum duration of consecutive NaNs to allow before interpolating.
    latitude : float
        The latitude of the location, required for sun-related interpolations.
    longitude : float
        The longitude of the location, required for sun-related interpolations.
    warning_threshold : float
        The fraction of data that can be excluded from interpolation before a warning is issued. Defaults to 0.1.

    Methods:
    --------
    run_interpolator(dataframe, **kwargs):
        An abstract method to be implemented by subclasses for interpolation.

    Raises:
    -------
    ValueError
        If the provided parameters are not valid.
    """

    WARNING_THRESHOLD = 0.1

    def __init__(
        self,
        interpolation_method: str,
        max_consecutive_nans_duration: pd.Timedelta,
        location: LocationInfo,
        time_zone: str,
        warning_threshold: float,
    ):
        """
        Initializes the base Interpolator class.

        Parameters:
        -----------
        interpolation_method : str
            The interpolation method to use.
        max_consecutive_nans_duration : pd.Timedelta
            The maximum duration of consecutive NaNs to allow before interpolating.
        location : LocationInfo
            An instance of LocationInfo representing the geographical location, required for sun-related interpolations.
            This object contains the latitude and longitude of the location, created using the astral library.
        time_zone : str
            The timezone of the location. This is required for sun-related interpolations.
        warning_threshold : float
            The fraction of data that can be excluded before a warning is issued.
        """
        # Validate parameters
        try:
            validation_executor = ValidationExecutor(
                interpolation_method=interpolation_method,
                max_consecutive_nans_duration=max_consecutive_nans_duration,
                warning_threshold=warning_threshold,
            )
            validation_executor.execute()
        except ValueError as e:
            logger.error(f"Validation error: {e}")
            raise

        self.interpolation_method = interpolation_method
        self.max_consecutive_nans_duration = max_consecutive_nans_duration
        if not isinstance(location, LocationInfo):
            raise ValueError(
                "location must be an instance of LocationInfo of Astral library."
            )
        self.location = location
        self.time_zone = time_zone
        self.warning_threshold = warning_threshold or self.WARNING_THRESHOLD
        self.maximum_gaps_allowed = None

        if warning_threshold is None:
            logger.warning(
                f"Warning threshold not provided. Using default value of {self.WARNING_THRESHOLD}"
            )

    def _get_step_count_from_max_consecutive_nans(self, frequency_of_data: str):
        """
        Converts a Timedelta to an equivalent number of steps based on the data frequency.

        Parameters:
        -----------
        timedelta : pd.Timedelta
            The time duration to be converted.
        frequency_of_data : str
            The frequency string of the DataFrame's index.

        Returns:
        --------
        int
            The equivalent number of steps.
        """
        base_period = pd.tseries.frequencies.to_offset(frequency_of_data)
        # In case of downsampling interpolation, max_consecutive_nans_duration is larger than base period,
        # so we need to ceil it to 1.
        return int(np.ceil(self.max_consecutive_nans_duration / base_period))

    def _warn_excessive_exclusion(self, dataframe: pd.DataFrame):
        """
        Warns if a significant fraction of data is excluded due to consecutive NaNs in any column.

        Parameters:
        -----------
        dataframe : pd.DataFrame
            The DataFrame to analyze for excessive data exclusion.
        """
        frequency_of_data_in_string, _ = calculate_frequency_in_integer_minutes(
            dataframe.index
        )
        self.maximum_gaps_allowed = self._get_step_count_from_max_consecutive_nans(
            frequency_of_data_in_string
        )
        for column in dataframe.columns:
            series = dataframe[column]
            mask = (
                series.isna()
                .astype(int)
                .groupby(series.notna().astype(int).cumsum())
                .cumsum()
            )
            excluded_data = mask[mask > self.maximum_gaps_allowed]
            fraction_excluded = len(excluded_data) / len(series)

            if fraction_excluded > self.warning_threshold:
                warnings.warn(
                    f"Column '{column}': Fraction of excluded data ({100 * fraction_excluded:0.02f}%) exceeded "
                    f"threshold",
                    UserWarning,
                )

    def _get_sun_times_for_date(self, date: datetime.date):
        """
        Fetches the sunrise and sunset times for a specific date using the SunTimes class.

        Parameters:
        -----------
        date : datetime.date
            The specific date for which to fetch the sun times. Defaults to the current date.
        """
        sun_times = SunTimes(self.location)
        return sun_times.get_sun_times(
            specific_date=date, return_datetime=True, timezone_to_return=self.time_zone
        )

    @abstractmethod
    def run_interpolator(self, dataframe: pd.DataFrame, **kwargs):
        """
        Abstract method for interpolating missing values in the DataFrame.
        Must be implemented by subclasses.
        """
        pass
