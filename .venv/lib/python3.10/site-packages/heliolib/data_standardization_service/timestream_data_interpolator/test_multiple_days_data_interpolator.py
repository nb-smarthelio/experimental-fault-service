import pytest
import pandas as pd
import numpy as np
from astral import LocationInfo

from .multiple_days_data_interpolator import MultipleDaysInterpolator


def create_test_dataframe(
    start, end, freq, timezone="UTC", missing_period_list: list = None
):
    """
    Create a test DataFrame with a specified date range, frequency, and optional missing periods.

    This function generates a DataFrame with random values for each date in the specified date range.
    If missing_period_list is provided, the corresponding values in the DataFrame are set to NaN.

    Parameters:
    -----------
    start : str
        The start date for the date range.
    end : str
        The end date for the date range.
    freq : str
        The frequency of the date range.
    timezone : str, optional
        The timezone for the date range (default is "UTC").
    missing_period_list : list, optional
        A list of tuples specifying the start and end dates for missing periods (default is None).

    Returns:
    --------
    pd.DataFrame
        A DataFrame with random values for each date in the date range.

    Example:
    --------
        ->>> create_test_dataframe(
        ...     start="2022-01-01",
        ...     end="2022-01-10",
        ...     freq="D",
        ...     timezone="UTC",
        ...     missing_period_list=[("2022-01-04", "2022-01-06")],
        ... )
        datetime
        2022-01-01    0.579
        2022-01-02    0.827
        2022-01-03    0.361
        2022-01-04      NaN
        2022-01-05      NaN
        2022-01-06      NaN
        2022-01-07    0.245
        2022-01-08    0.159
        2022-01-09    0.828
        2022-01-10    0.398
        Freq: D, Name: value, dtype: float64
    """
    # Generate a date range based on the start, end, and frequency parameters
    date_range = pd.date_range(start=start, end=end, freq=freq, tz=timezone)

    # Generate random values for each date in the date range
    data = {
        "value_1": np.random.rand(len(date_range)),
        "value_2": np.random.rand(len(date_range)),
    }

    # Create a DataFrame using the generated data and index it with the date range
    df = pd.DataFrame(data, index=date_range)

    # If missing_period_list is provided, set the corresponding values in the DataFrame to NaN
    if missing_period_list:
        for missing_period in missing_period_list:
            start_missing, end_missing = missing_period
            df.loc[start_missing:end_missing, "value_1"] = np.nan
            df.loc[start_missing:end_missing, "value_2"] = np.nan

    return df


def test_multiple_days_data_interpolator_initialization():
    """
    Test the initialization of the MultipleDaysInterpolator object.

    This test checks that the MultipleDaysInterpolator object is initialized correctly with the provided parameters.
    It verifies that the interpolator is an instance of the MultipleDaysInterpolator class, and that the latitude,
    longitude, warning threshold, maximum consecutive NaNs duration, and interpolation method are initialized correctly.
    """
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    timezone = "America/Denver"
    # Initialize the MultipleDaysInterpolator object with the provided parameters
    interpolator = MultipleDaysInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location,
        time_zone=timezone,
        warning_threshold=0.1,
    )

    # Check that the interpolator is an instance of the MultipleDaysInterpolator class
    assert isinstance(interpolator, MultipleDaysInterpolator)

    # Check that the latitude is initialized correctly
    assert (
        interpolator.location.latitude == 40.0
    ), "Latitude should be initialized correctly"

    # Check that the longitude is initialized correctly
    assert (
        interpolator.location.longitude == -105.0
    ), "Longitude should be initialized correctly"

    # Check that the warning threshold is initialized correctly
    assert (
        interpolator.warning_threshold == 0.1
    ), "Warning threshold should be initialized correctly"

    # Check that the maximum consecutive NaNs duration is initialized correctly
    assert interpolator.max_consecutive_nans_duration == pd.Timedelta(
        minutes=30
    ), "Maximum gaps allowed should be initialized correctly"

    # Check that the interpolation method is initialized correctly
    assert (
        interpolator.interpolation_method == "linear"
    ), "Interpolation method should be initialized correctly"


def test_run_interpolator_multiple_days_with_custom_timezone():
    """
    Test the run_interpolator method of the MultipleDaysInterpolator class.

    This test creates a test DataFrame with missing periods and then applies the MultipleDaysInterpolator
    to interpolate the missing values. It checks that there are no NaN values in the interpolated DataFrame.

    Example:
    -----------
        -->>> test_run_interpolator_multiple_days()
        No assertion errors should be raised.
    """
    # Create a test DataFrame with missing periods
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-04 23:59",
        freq="T",
        timezone="America/Denver",
        missing_period_list=[
            ("2023-01-01 08:00", "2023-01-01 08:29"),
            ("2023-01-03 09:00", "2023-01-03 09:29"),
        ],  # 1 hour missing data for the multiple days
    )
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    timezone = "America/Denver"
    # Create a MultipleDaysInterpolator object
    interpolator = MultipleDaysInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location,
        time_zone=timezone,
        warning_threshold=0.1,
    )

    # Apply the interpolator to interpolate missing values
    interpolated_df = interpolator.run_interpolator(df)
    date = df.index[0].date()
    sunrise, sunset = interpolator._get_sun_times_for_date(date)

    assert (
        interpolated_df.between_time(str(sunrise.time()), str(sunset.time()))
        .isna()
        .sum()
        .sum()
        == 0
    ), "There should be no NaN values after interpolation"


def test_interpolator_with_excessive_missing_values():
    """
    Test the interpolator with excessive missing values.

    This test creates a test DataFrame with a missing period of 24 hours for multiple days.
    It initializes the interpolator and applies it to interpolate the missing values.
    The test checks that a UserWarning is raised during the interpolation process.
    """
    # Create a test DataFrame with a missing period of 24 hours for multiple days
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-04 23:59",
        freq="T",
        timezone="America/Denver",
        missing_period_list=[
            ("2023-01-01 09:00", "2023-01-02 15:59"),
        ],
    )
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    # Initialize the interpolator with the provided parameters
    interpolator = MultipleDaysInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location,
        time_zone="America/Denver",
        warning_threshold=0.1,
    )

    # Use pytest to check that a UserWarning is raised during the interpolation process
    with pytest.warns(UserWarning):
        interpolated_df = interpolator.run_interpolator(df)


def test_interpolator_for_empty_dataframe():
    """
    Test the interpolator with an empty DataFrame.

    This test creates an empty DataFrame and initializes the interpolator.
    It checks that an AttributeError is raised when applying the interpolator to the empty DataFrame.
    """
    # Create an empty DataFrame
    df = pd.DataFrame({})
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    timezone = "America/Denver"
    # Initialize the interpolator with the provided parameters
    interpolator = MultipleDaysInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location,
        time_zone=timezone,
        warning_threshold=0.1,
    )

    # Use pytest to check that an AttributeError is raised when applying the interpolator to the empty DataFrame
    with pytest.raises(AttributeError) as error:
        interpolated_df = interpolator.run_interpolator(dataframe=df)

    # Check that the error message matches the expected error message
    assert str(error.value) == "'RangeIndex' object has no attribute 'date'"
