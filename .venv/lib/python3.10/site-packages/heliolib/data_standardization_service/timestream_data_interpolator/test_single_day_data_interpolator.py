import datetime

import numpy as np
import pandas as pd
import pytest
from astral import LocationInfo

from .single_day_data_interpolator import (
    DailyDataInterpolator,
)  # Adjust the import according to your module structure


# Utility function to create a test DataFrame
def create_test_dataframe(start, end, freq, timezone="UTC", missing_period=None):
    date_range = pd.date_range(start=start, end=end, freq=freq, tz=timezone)
    data = {
        "value_1": np.random.rand(len(date_range)),
        "value_2": np.random.rand(len(date_range)),
    }
    df = pd.DataFrame(data, index=date_range)

    if missing_period:
        start_missing, end_missing = missing_period
        df.loc[start_missing:end_missing, "value_1"] = np.nan
        df.loc[start_missing:end_missing, "value_2"] = np.nan

    return df


@pytest.fixture
def location_info_utc():
    """Fixture for creating a LocationInfo object for UTC."""
    return LocationInfo(latitude=0.0, longitude=0.0, timezone="UTC")


@pytest.fixture
def location_info_ny():
    """Fixture for creating a LocationInfo object for New York."""
    return LocationInfo(
        latitude=40.7128, longitude=-74.0060, timezone="America/New_York"
    )


@pytest.fixture
def location_info_kolkata():
    """Fixture for creating a LocationInfo object for Kolkata."""
    return LocationInfo(latitude=22.5726, longitude=88.3639, timezone="Asia/Kolkata")


def test_daily_data_interpolator_initialization(location_info_utc):
    """Test the initialization of the DailyDataInterpolator."""
    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_utc,
        time_zone="UTC",
        warning_threshold=0.1,
    )
    assert (
        interpolator.location == location_info_utc
    ), "LocationInfo should be initialized correctly"
    assert interpolator.time_zone == "UTC", "Time zone should be initialized correctly"
    assert (
        interpolator.warning_threshold == 0.1
    ), "Warning threshold should be initialized correctly"
    assert interpolator.max_consecutive_nans_duration == pd.Timedelta(
        minutes=30
    ), "Maximum gaps allowed should be initialized correctly"
    assert (
        interpolator.interpolation_method == "linear"
    ), "Interpolation method should be initialized correctly"


def test_run_interpolator_single_day(location_info_utc):
    """Test run_interpolator with a single day's data."""
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-01 23:59",
        freq="T",
        timezone="UTC",
        missing_period=("2023-01-01 02:00", "2023-01-01 02:59"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_utc,
        time_zone="UTC",
        warning_threshold=0.1,
    )
    interpolated_df = interpolator.run_interpolator(df)
    date = df.index[0].date()
    sunrise, sunset = interpolator._get_sun_times_for_date(date)

    assert (
        interpolated_df.between_time(str(sunrise.time()), str(sunset.time()))
        .isna()
        .sum()
        .sum()
        == 0
    ), "There should be no NaN values after interpolation during daylight hours"


def test_run_interpolator_invalid_timezone(location_info_ny):
    """Test run_interpolator with a DataFrame that has a mismatched timezone."""
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-01 23:59",
        freq="T",
        timezone="America/New_York",
    )
    df.index = df.index.tz_convert("UTC")  # Convert to a different timezone

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_ny,
        time_zone="America/New_York",
        warning_threshold=0.1,
    )
    with pytest.raises(
        ValueError, match="Dataframe timezone does not match the provided timezone."
    ):
        interpolator.run_interpolator(df)


def test_extract_unique_date(location_info_utc):
    """Test _extract_unique_date with a valid single-day DataFrame."""
    df = create_test_dataframe(
        start="2023-01-01 00:00", end="2023-01-01 23:59", freq="T", timezone="UTC"
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_utc,
        time_zone="UTC",
        warning_threshold=0.1,
    )

    extracted_date = interpolator._extract_unique_date(df)
    assert extracted_date == datetime.date(
        2023, 1, 1
    ), "Extracted date should be 2023-01-01"


def test_extract_unique_date_failure(location_info_utc):
    """Test _extract_unique_date with a DataFrame containing multiple days."""
    df = create_test_dataframe(
        start="2023-01-01 00:00", end="2023-01-02 23:59", freq="T", timezone="UTC"
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_utc,
        time_zone="UTC",
        warning_threshold=0.1,
    )

    with pytest.raises(
        ValueError, match="Dataframe should contain data for only one day."
    ):
        interpolator._extract_unique_date(df)


def test_interpolator_with_excessive_missing_values(location_info_utc):
    """Test interpolation with excessive missing values exceeding the allowed duration."""
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-01 23:59",
        freq="T",
        timezone="UTC",
        missing_period=(
            "2023-01-01 05:00",
            "2023-01-01 15:59",
        ),  # 11 hours of missing data
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_utc,
        time_zone="UTC",
        warning_threshold=0.1,
    )

    with pytest.warns(UserWarning):
        interpolator.run_interpolator(df)


def test_interpolation_excluding_night_hours(location_info_utc):
    """Test interpolation excluding night hours."""
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-01 23:59",
        freq="T",
        timezone="UTC",
        missing_period=("2023-01-01 00:00", "2023-01-01 05:59"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_utc,
        time_zone="UTC",
        warning_threshold=0.1,
    )

    # Mock the _get_sun_times_for_date method to return fixed sunrise and sunset times
    interpolator._get_sun_times_for_date = lambda date: (
        pd.Timestamp("2023-01-01 06:00:00", tz="UTC"),
        pd.Timestamp("2023-01-01 18:00", tz="UTC"),
    )

    interpolated_df = interpolator.run_interpolator(df)

    # Verify that night hours data still exists in the DataFrame
    night_hours = (interpolated_df.index.hour < 6) | (interpolated_df.index.hour > 18)
    assert (
        len(interpolated_df[night_hours]) > 0
    ), "Night hours should exist in the interpolated DataFrame"

    # Verify that day hours are interpolated
    day_hours = (interpolated_df.index.hour >= 6) & (interpolated_df.index.hour < 18)
    assert (
        not interpolated_df[day_hours].isna().any().any()
    ), "Day hours should be interpolated"


def test_interpolator_new_york_standard_time(location_info_ny):
    """Test interpolation in New York during standard time."""
    df = create_test_dataframe(
        start="2023-01-15 00:00",
        end="2023-01-15 23:59",
        freq="T",
        timezone="America/New_York",
        missing_period=("2023-01-15 09:00", "2023-01-15 09:29"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_ny,
        time_zone="America/New_York",
        warning_threshold=0.1,
    )
    interpolated_df = interpolator.run_interpolator(df)
    # interpolated_df should not have any NaN values between 2:00 and 2:59
    assert interpolated_df.isna().sum().sum() == 0, (
        "There should be no NaN values " "after interpolation in New York Standard Time"
    )


def test_interpolator_new_york_daylight_saving_time(location_info_ny):
    """Test interpolation in New York during daylight saving time."""
    df = create_test_dataframe(
        start="2023-07-01 00:00",
        end="2023-07-01 23:59",
        freq="T",
        timezone="America/New_York",
        missing_period=("2023-07-01 09:00", "2023-07-01 09:29"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_ny,
        time_zone="America/New_York",
        warning_threshold=0.1,
    )
    interpolated_df = interpolator.run_interpolator(df)
    assert (
        not interpolated_df.isna().any().any()
    ), "There should be no NaN values after interpolation in New York Daylight Saving Time"


def test_interpolator_kolkata(location_info_kolkata):
    """Test interpolation in Kolkata, which does not observe DST."""
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-01 23:59",
        freq="T",
        timezone="Asia/Kolkata",
        missing_period=("2023-01-01 12:00", "2023-01-01 12:15"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info_kolkata,
        time_zone="Asia/Kolkata",
        warning_threshold=0.1,
    )
    interpolated_df = interpolator.run_interpolator(df)
    assert (
        not interpolated_df.isna().any().any()
    ), "There should be no NaN values after interpolation in Kolkata Time"


def test_interpolator_london_standard_time():
    """Test interpolation in London during standard time."""
    location_info = LocationInfo(
        latitude=51.5074, longitude=-0.1278, timezone="Europe/London"
    )
    df = create_test_dataframe(
        start="2023-01-15 00:00",
        end="2023-01-15 23:59",
        freq="T",
        timezone="Europe/London",
        missing_period=("2023-01-15 10:00", "2023-01-15 10:29"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info,
        time_zone="Europe/London",
        warning_threshold=0.1,
    )
    interpolated_df = interpolator.run_interpolator(df)
    assert (
        not interpolated_df.isna().any().any()
    ), "There should be no NaN values after interpolation in London Standard Time"


def test_interpolator_london_daylight_saving_time():
    """Test interpolation in London during daylight saving time."""
    location_info = LocationInfo(
        latitude=51.5074, longitude=-0.1278, timezone="Europe/London"
    )
    df = create_test_dataframe(
        start="2023-07-01 00:00",
        end="2023-07-01 23:59",
        freq="T",
        timezone="Europe/London",
        missing_period=("2023-07-01 10:00", "2023-07-01 10:29"),
    )

    interpolator = DailyDataInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location_info,
        time_zone="Europe/London",
        warning_threshold=0.1,
    )
    interpolated_df = interpolator.run_interpolator(df)
    assert (
        not interpolated_df.isna().any().any()
    ), "There should be no NaN values after interpolation in London Daylight Saving Time"
