import datetime
import zoneinfo
from astral import LocationInfo
import pytest
import pandas as pd
import numpy as np
from .timestream_data_interpolator import Interpolator


def test_interpolator_initialization_raises_error_as_abstract_class():
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    with pytest.raises(TypeError) as e:
        Interpolator(
            interpolation_method="linear",
            max_consecutive_nans_duration=pd.Timedelta(minutes=15),
            location=location,
            time_zone="Asia/Kolkata",
            warning_threshold=0.5,
        )
    assert (
        str(e.value)
        == "Can't instantiate abstract class Interpolator with abstract method run_interpolator"
    )


# Create a Concrete Subclass for Testing
class TestInterpolator(Interpolator):
    def run_interpolator(self, dataframe: pd.DataFrame, **kwargs):
        pass  # Simple implementation for testing


# Test Initialization and Parameter Validation
def test_interpolator_initialization():
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    with pytest.raises(ValueError):
        TestInterpolator(
            interpolation_method="invalid_method",
            max_consecutive_nans_duration=pd.Timedelta(minutes=15),
            location=location,
            time_zone="Asia/Kolkata",
            warning_threshold=0.5,
        )


# Test for _get_step_count_from_max_consecutive_nans
def test_get_step_count_from_max_consecutive_nans():
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    interpolator = TestInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location,
        time_zone="Asia/Kolkata",
        warning_threshold=0.1,
    )

    frequency_of_data = "15T"  # 15 minutes
    expected_steps = 2  # 30 minutes / 15 minutes per step

    steps = interpolator._get_step_count_from_max_consecutive_nans(frequency_of_data)
    assert steps == expected_steps, f"Expected steps: {expected_steps}, got: {steps}"


def create_test_dataframe(start, end, freq, timezone="UTC", missing_period=None):
    date_range = pd.date_range(start=start, end=end, freq=freq, tz=timezone)
    data = {"value": np.random.rand(len(date_range))}
    df = pd.DataFrame(data, index=date_range)

    if missing_period:
        start_missing, end_missing = missing_period
        df.loc[start_missing:end_missing, "value"] = np.nan

    return df


# Test for _warn_excessive_exclusion
def test_warn_excessive_exclusion():
    df = create_test_dataframe(
        start="2023-01-01 00:00",
        end="2023-01-01 23:59",
        freq="T",
        missing_period=("2023-01-01 00:00", "2023-01-01 05:59"),  # 6 hours missing data
    )
    location = LocationInfo(latitude=40.0, longitude=-105.0)
    interpolator = TestInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=15),
        location=location,
        time_zone="UTC",
        warning_threshold=0.1,
    )

    with pytest.warns(UserWarning):
        interpolator._warn_excessive_exclusion(df)


# Test for _get_sun_times_for_date
def test_get_sun_times_for_date():
    location = LocationInfo(latitude=28.679079, longitude=77.069710)
    interpolator = TestInterpolator(
        interpolation_method="linear",
        max_consecutive_nans_duration=pd.Timedelta(minutes=30),
        location=location,
        time_zone="Asia/Kolkata",
        warning_threshold=0.1,
    )

    date = datetime.date(2023, 6, 21)
    sunrise, sunset = interpolator._get_sun_times_for_date(date)
    assert isinstance(sunrise, datetime.datetime), "Sunrise time should be a Timestamp"
    assert isinstance(sunset, datetime.datetime), "Sunset time should be a Timestamp"
    # assert timezones are correct
    assert sunrise.tzinfo == zoneinfo.ZoneInfo(
        key="Asia/Kolkata"
    ), "Sunrise should be in Asia/Kolkata"
    assert sunset.tzinfo == zoneinfo.ZoneInfo(
        key="Asia/Kolkata"
    ), "Sunset should be in Asia/Kolkata"
