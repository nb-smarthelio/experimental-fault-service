import logging

import pandas as pd

logger = logging.getLogger(__name__)


class TargetFrequencyValidator:
    @staticmethod
    def validate_whether_target_freq_is_correct_type(target_freq):
        if not isinstance(target_freq, pd.Timedelta):
            raise ValueError(
                "target_freq must be a Pandas Timedelta, pd.Timedelta object."
            )
        else:
            logger.debug(f"Provided target_freq: {target_freq} is valid")


class InterpolationMethodValidator:
    ALLOWED_METHODS = [
        "linear",
        "time",
        "index",
        "value",
        "pad",
        "nearest",
        "zero",
        "slinear",
        "quadratic",
        "cubic",
        "spline",
        "barycentric",
        "polynomial",
    ]

    @staticmethod
    def validate_whether_interpolation_method_is_acceptable(interpolation_method):
        if interpolation_method not in InterpolationMethodValidator.ALLOWED_METHODS:
            raise ValueError(
                f"Interpolation method must be one of the following: {InterpolationMethodValidator.ALLOWED_METHODS}"
            )
        else:
            logger.debug(
                f"Provided interpolation method: {interpolation_method} is valid"
            )


class TimeDeltaValidator:
    @staticmethod
    def validate_whether_max_consecutive_nans_duration_is_correct_type(
        max_consecutive_nans_duration,
    ):
        if not isinstance(max_consecutive_nans_duration, pd.Timedelta):
            raise ValueError(
                "max_consecutive_nans_duration must be a Pandas Timedelta, pd.Timedelta object."
            )
        else:
            logger.debug(
                f"Provided max_consecutive_nans_duration: {max_consecutive_nans_duration} is valid"
            )


class WarningThresholdValidator:
    LOWER_BOUND = 0.0
    UPPER_BOUND = 1.0

    @staticmethod
    def validate_whether_warning_threshold_is_meaningful(warning_threshold):
        if not isinstance(warning_threshold, float) or not (
            WarningThresholdValidator.LOWER_BOUND
            <= warning_threshold
            <= WarningThresholdValidator.UPPER_BOUND
        ):
            raise ValueError(
                f"warning_threshold must be a float between {WarningThresholdValidator.LOWER_BOUND} and "
                f"{WarningThresholdValidator.UPPER_BOUND}."
            )
        else:
            logger.debug(f"Provided warning_threshold: {warning_threshold} is valid")


class ValidationExecutor:
    VALIDATORS = {
        "max_consecutive_nans_duration": TimeDeltaValidator.validate_whether_max_consecutive_nans_duration_is_correct_type,
        "warning_threshold": WarningThresholdValidator.validate_whether_warning_threshold_is_meaningful,
        "target_freq": TargetFrequencyValidator.validate_whether_target_freq_is_correct_type,
        "interpolation_method": InterpolationMethodValidator.validate_whether_interpolation_method_is_acceptable,
    }

    def __init__(self, **kwargs):
        """
        Initializes the ValidationExecutor with named arguments representing variables to validate.

        Parameters:
        kwargs: Named arguments where the name corresponds to the variable and the value is the variable itself.
        """
        self.variables = kwargs

    def execute(self):
        """
        Executes the validation for each variable using its associated validator function.
        """
        for var_name, var_value in self.variables.items():
            validator = self.VALIDATORS.get(var_name)
            if validator is None:
                raise ValueError(f"No validator found for variable: {var_name}")
            if var_value is None:
                raise ValueError(f"Value for {var_name} cannot be None")
            validator(var_value)


# Example usage
# max_timedelta = pd.Timedelta("30T")
# warning_threshold = 0.1
#
# validation_executor = ValidationExecutor(max_timedelta=max_timedelta, warning_threshold=warning_threshold)
# validation_executor.execute()
