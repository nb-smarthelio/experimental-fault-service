import time
from typing import Any, Callable, Dict, List, Optional

import requests
import requests_cache
from requests import Session
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

from heliolib.metadata_extraction_service.authentication_interceptor import (
    AuthInterceptor,
)


class MetadataAPI:
    # Constants for configuration
    DEFAULT_PAGE_SIZE = 1000
    DEFAULT_EXPIRATION_SECONDS = 3600
    REQUIRED_AUTH_PARAMS = frozenset(["email", "password", "auth_url"])
    RETRY_STATUS_CODES = frozenset([401, 403, 408, 429, 500, 502, 503, 504])

    def __init__(self, base_url: str, options: Dict[str, Any]):
        """
        Initializes the MetadataAPI class for handling metadata API requests.

        Parameters
        ----------
        base_url : str
            The base URL of the metadata API.
        options : Dict[str, Any]
            A dictionary containing authentication credentials:
            Required: "email", "password", "auth_url"
            Optional:
                - "expiration_period_seconds" (defaults to 3600)
                - "page_size" (defaults to 1000)

        Raises
        ------
        ValueError
            If required authentication credentials are missing.
        """
        self.base_url = base_url.rstrip("/")
        self._validate_options(options)

        self.page_size = options.get("page_size", self.DEFAULT_PAGE_SIZE)
        self.auth_interceptor = self._init_auth_interceptor(options)
        self.session = self._init_cached_session()

    def _with_retries(
        self,
        func: Callable[[], Any],
        retries: int = 3,
        delay: float = 1.0,
        retry_exceptions: tuple = (
            requests.exceptions.ConnectionError,
            requests.exceptions.HTTPError,
        ),
    ) -> Any:
        """
        Generic retry wrapper with exponential backoff.

        Parameters
        ----------
        func : Callable
            The function to call with retry logic.
        retries : int
            Maximum number of retries.
        delay : float
            Initial delay (will double with each retry).
        retry_exceptions : tuple
            Exceptions to retry on.

        Returns
        -------
        Any
            The result of the callable if successful.

        Raises
        ------
        Exception
            The last exception raised if retries fail.
        """
        for attempt in range(retries):
            try:
                return func()
            except retry_exceptions as e:
                if attempt < retries - 1:
                    time.sleep(delay * (2**attempt))  # exponential backoff
                else:
                    raise

    def _validate_options(self, options: Dict[str, Any]) -> None:
        """Validates the options dictionary for required parameters."""
        missing_params = self.REQUIRED_AUTH_PARAMS - options.keys()
        if missing_params:
            raise ValueError(
                f"Missing required authentication parameters: {', '.join(missing_params)}"
            )

    def _init_auth_interceptor(self, options: Dict[str, Any]) -> AuthInterceptor:
        """Initializes and returns the authentication interceptor."""
        return AuthInterceptor(
            email=options["email"],
            password=options["password"],
            auth_url=options["auth_url"],
            expiration_period_seconds=options.get(
                "expiration_period_seconds", self.DEFAULT_EXPIRATION_SECONDS
            ),
        )

    def _init_cached_session(self) -> requests_cache.CachedSession:
        """Initializes and returns a cached session."""
        return requests_cache.CachedSession(
            cache_name="metadata_api_cache",
            expire_after=self.DEFAULT_EXPIRATION_SECONDS,
            backend="memory",
            fast_save=True,
        )

    def _retry_session(
        self, url: str, allowed_request_type: Optional[List[str]] = None
    ) -> Session:
        """
        Configures and returns a requests session with retry logic.

        Parameters
        ----------
        url : str
            The base URL to mount the adapter for retries.
        allowed_request_type : Optional[List[str]], default=None
            A list of HTTP methods allowed for retries. Defaults to ["GET"] if not provided.

        Returns
        -------
        Session
            A requests session configured with retry logic.
        """
        allowed_request_type = allowed_request_type or ["GET"]

        retry = Retry(
            total=3,
            backoff_factor=1,
            status_forcelist=self.RETRY_STATUS_CODES,
            allowed_methods=frozenset(allowed_request_type),
            respect_retry_after_header=True,
        )

        self.session.mount(url, HTTPAdapter(max_retries=retry))
        return self.session

    def _make_request(self, url: str, params: Dict[str, Any]) -> Dict[str, Any]:
        """Makes an authenticated request to the API."""
        token = self.auth_interceptor.get_access_token()
        headers = {"Authorization": f"Bearer {token}"}

        response = self.session.get(url=url, params=params, headers=headers)
        response.raise_for_status()

        data = response.json()
        if "data" not in data or data["data"] is None:
            raise ValueError(
                f'API returned errors: {data.get("errors", "Unknown error")}'
            )

        return data

    def _paginate_request(
        self, url: str, page_size: Optional[int] = None
    ) -> List[Dict[str, Any]]:
        """
        Fetches paginated data from the metadata API.

        Parameters
        ----------
        url : str
            The API endpoint URL for retrieving paginated data.
        page_size : Optional[int], default=None
            The number of records per page. Defaults to self.page_size if not provided.

        Returns
        -------
        List[Dict[str, Any]]
            A list of dictionaries containing the retrieved metadata.

        Raises
        ------
        ValueError
            If the API response contains errors.
        requests.exceptions.HTTPError
            If the API request fails with a non-retryable HTTP error.
        ConnectionError
            If there's a connection issue with the API.
        """
        all_data = []
        page = 1
        current_page_size = page_size or self.page_size

        self._retry_session(url=url, allowed_request_type=["GET"])

        while True:
            try:
                params = {
                    "showDeleted": "false",
                    "page": page,
                    "pageSize": current_page_size,
                }

                data = self._with_retries(lambda: self._make_request(url, params))
                page_data = data["data"]
                all_data.extend(page_data)

                if len(page_data) < current_page_size:
                    break

                page += 1

            except requests.exceptions.ConnectionError:
                raise
            except requests.exceptions.HTTPError:
                raise

        return all_data

    def _single_request(self, url: str) -> Optional[Dict[str, Any]]:
        """
        Sends a single GET request to the metadata API and returns the response data.

        Parameters
        ----------
        url : str
            The API endpoint URL to fetch data from.

        Returns
        -------
        Optional[Dict[str, Any]]
            A dictionary containing the API response data.

        Raises
        ------
        ValueError
            If the API response contains errors.
        HTTPError
            If the API request fails with an HTTP error.
        """
        self._retry_session(url=url, allowed_request_type=["GET"])

        try:
            data = self._with_retries(
                lambda: self._make_request(url, {"showDeleted": "false"})
            )
            return data["data"]
        except requests.exceptions.HTTPError as e:
            if e.response.status_code != 200:
                raise
            return None

    def get_all_companies_data_from_company_table(self) -> List[Dict[str, Any]] | List:
        """
        Retrieves all company data from the metadata API.

        Returns
        -------
        List[Dict[str, Any]] | List
            A list of dictionaries containing company metadata.
        """
        api_url = f"{self.base_url}/v2/companies"
        api_data = self._paginate_request(url=api_url)
        return api_data

    def get_all_hardware_models_data_by_table_name(
        self, table_name: str
    ) -> List[Dict[str, Any]] | List:
        """
        Retrieves all hardware models data for a specified table name.

        Parameters
        ----------
        table_name : str
            The name of the table to fetch hardware models from, i.e., panel and inverter-model.

        Returns
        -------
        List[Dict[str, Any]] | List
            A list of dictionaries containing hardware model data.
        """
        api_url = f"{self.base_url}/v2/{table_name}"
        api_data = self._paginate_request(url=api_url)
        return api_data

    def get_company_data_by_plant_id(self, plant_id: str) -> Dict[str, Any] | None:
        """
        Retrieves company data associated with a given plant ID.

        Parameters
        ----------
        plant_id : str
            The plant ID to fetch associated company data.

        Returns
        -------
        Dict[str, Any] | None
            A dictionary containing the company metadata.
        """
        api_url = f"{self.base_url}/v2/plant/{plant_id}/company"
        api_data = self._single_request(url=api_url)
        return api_data

    def get_plant_data_by_company_id_and_plant_id(
        self, company_id: str, plant_id: str
    ) -> Dict[str, Any] | None:
        """
        Retrieves plant data for a given company and plant ID.

        Parameters
        ----------
        company_id : str
            The company ID associated with the plant.
        plant_id : str
            The plant ID to fetch plant data.

        Returns
        -------
        Dict[str, Any] | None
            A dictionary containing plant metadata.
        """
        api_url = f"{self.base_url}/v2/companies/{company_id}/plants/{plant_id}"
        api_data = self._single_request(url=api_url)
        return api_data

    def get_plant_metadata_table_by_plant_id(
        self, company_id: str, plant_id: str, table_name: str
    ) -> List[Dict[str, Any]]:
        """
        Retrieves metadata from a specific table for a given plant.

        Parameters
        ----------
        company_id : str
            The company ID associated with the plant.
        plant_id : str
            The plant ID to fetch metadata for.
        table_name : str
            The table name from which to fetch metadata.

        Returns
        -------
        List[Dict[str, Any]] | List
            A list of dictionaries containing metadata records.
        """
        api_url = (
            f"{self.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s"
        )
        all_data = self._paginate_request(url=api_url)
        return all_data

    def get_all_credentials_data_by_company_id(
        self, company_id: str
    ) -> List[Dict[str, Any]] | List:
        """
        Retrieves all credentials data for a given company.

        Parameters
        ----------
        company_id : str
            The company ID to fetch credentials data.

        Returns
        -------
        List[Dict[str, Any]] | List
            A list of dictionaries containing credential metadata.
        """
        api_url = f"{self.base_url}/v2/companies/{company_id}/credentials"
        all_data = self._paginate_request(url=api_url)
        return all_data

    def get_all_plants_data_by_company_id(
        self, company_id: str
    ) -> List[Dict[str, Any]] | List:
        """
        Retrieves all plant data for a given company.

        Parameters
        ----------
        company_id : str
            The company ID to fetch plants data.

        Returns
        -------
        List[Dict[str, Any]] | List
            A list of dictionaries containing plant metadata.
        """
        api_url = f"{self.base_url}/v2/companies/{company_id}/plants"
        all_data = self._paginate_request(url=api_url)
        return all_data

    def get_plant_metadata_by_plant_id_table_name_and_table_id(
        self, company_id: str, plant_id: str, table_name: str, table_id: str
    ) -> Dict[str, Any] | None:
        """
        Retrieves metadata for a specific record in a plant metadata table.

        Parameters
        ----------
        company_id : str
            The company ID associated with the plant.
        plant_id : str
            The plant ID to fetch metadata for.
        table_name : str
            The table name containing the record, i.e., inverter, mppt, string, tracker etc.
        table_id : str
            The unique ID of the record within the tables, i.e., values of inv_id, mppt_id, string_id etc.

        Returns
        -------
        Dict[str, Any] | None
            A dictionary containing the metadata for the specified record.
        """
        api_url = f"{self.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s/{table_id}"
        api_data = self._single_request(url=api_url)
        return api_data

    def get_credentials_data_by_company_id_and_credential_id(
        self, company_id: str, credential_id: str
    ) -> Dict[str, Any] | None:
        """
        Retrieves specific credential data for a given company.

        Parameters
        ----------
        company_id : str
            The company ID associated with the credential.
        credential_id : str
            The unique ID of the credential.

        Returns
        -------
        Dict[str, Any] | None
            A dictionary containing the credential metadata.
        """
        api_url = (
            f"{self.base_url}/v2/companies/{company_id}/credentials/{credential_id}"
        )
        api_data = self._single_request(url=api_url)
        return api_data

    def get_company_name(self, plant_id: str) -> str | None:
        """
        Retrieves the company name associated with a given plant ID.

        Parameters
        ----------
        plant_id : str
            The plant ID to fetch the associated company name.

        Returns
        -------
        str | None
            The company name associated with the plant ID.
        """
        company_data = self.get_company_data_by_plant_id(plant_id=plant_id)
        return company_data["company_name"] if company_data else None
