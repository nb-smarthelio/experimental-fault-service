import json
import os
from typing import Any, Dict, List
from unittest.mock import Mock

import pytest
from requests.exceptions import ConnectionError, HTTPError

from .metadata_functions import MetadataAPI


def load_mock_data(file_name: str) -> dict:
    """
    Loads mock data from a file (JSON) for testing.

    Parameters
    ----------
    file_name : str
        The name of the mock file to load.

    Returns
    -------
    pd.DataFrame | dict
        A Pandas DataFrame if the file is CSV, or a dictionary if JSON.

    Raises
    ------
    ValueError
        If the file format is unsupported.
    """
    mock_file_path = os.path.join(
        os.path.dirname(__file__), "mocks/metadata_functions", file_name
    )

    if file_name.endswith(".json"):
        with open(mock_file_path, "r") as file:
            return json.load(file)
    else:
        raise ValueError(f"Unsupported file format: {file_name}")


@pytest.fixture
def metadata_api():
    """
    Fixture to create a properly initialized MetadataAPI with mocked auth interceptor.
    """
    base_url = "https://api.example.com"
    options = {
        "email": "test@example.com",
        "password": "password123",
        "auth_url": "https://auth.example.com",
    }

    # Create API instance with mocked auth_interceptor
    api = MetadataAPI(base_url, options)
    # Mock the auth interceptor to return a token
    api.auth_interceptor.get_access_token = Mock(return_value="test-token")
    return api


@pytest.mark.parametrize(
    "status_codes, expected_company_name_index, expected_company_name, expected_data_length",
    [([200], 0, "Company_1", 4)],
)
def test_paginate_request_successful_retry(
    mocker,
    metadata_api,
    status_codes,
    expected_company_name_index,
    expected_company_name,
    expected_data_length,
):
    mock_data = load_mock_data("get_all_companies_response.json")["data"]

    responses = []
    for code in status_codes:
        if code >= 400:
            error_response = Mock()
            error_response.status_code = code
            http_error = HTTPError(f"HTTP Error: {code}")
            http_error.response = error_response
            responses.append(http_error)
        else:
            responses.append({"data": mock_data})

    make_request_mock = mocker.patch.object(
        metadata_api, "_make_request", side_effect=responses
    )

    result = metadata_api._paginate_request(f"{metadata_api.base_url}/v2/companies")

    assert isinstance(result, list)
    assert len(result) == expected_data_length
    assert result[expected_company_name_index]["company_name"] == expected_company_name
    assert make_request_mock.call_count == len(status_codes)


@pytest.mark.parametrize(
    "error_sequence, expected_exception, expected_error_message",
    [
        (
            [
                HTTPError("HTTP Error"),
                HTTPError("HTTP Error"),
                ConnectionError("Max retries exceeded"),
            ],
            ConnectionError,
            "Max retries exceeded",
        )
    ],
)
def test_paginate_request_failed_retry(
    mocker,
    metadata_api,
    error_sequence,
    expected_exception,
    expected_error_message,
):
    """
    Test that the `_paginate_request()` method fails after retryable errors.
    """
    # Patch _make_request to simulate retries
    make_request_mock = mocker.patch.object(
        metadata_api, "_make_request", side_effect=error_sequence
    )

    mocker.patch.object(
        metadata_api, "_retry_session", return_value=metadata_api.session
    )

    with pytest.raises(expected_exception) as exc_info:
        metadata_api._paginate_request(f"{metadata_api.base_url}/v2/companies")

    assert expected_error_message in str(exc_info.value)
    assert make_request_mock.call_count == len(error_sequence)


@pytest.mark.parametrize(
    "mock_file, expected_data_length, expected_company_name, expected_company_id_type",
    [("get_all_companies_response.json", 4, "Company_2", str)],
)
def test_get_all_companies_data_from_company_table_success(
    mocker,
    mock_file: str,
    expected_data_length: int,
    expected_company_name: str,
    expected_company_id_type: type,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_all_companies_data_from_company_table()` successfully retrieves and processes company data.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file name containing the expected company data.
        expected_company_name (str): The expected company name in the response data.
        expected_company_id_type (type): The expected type of the `company_id` field.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_companies_data_from_company_table()

    mock_request.assert_called_once_with(url=f"{metadata_api.base_url}/v2/companies")
    assert len(result["data"]) == expected_data_length
    assert result["data"][1]["company_name"] == expected_company_name
    assert isinstance(result["data"][3]["company_id"], expected_company_id_type)


@pytest.mark.parametrize("mock_data, expected_result", [({"data": []}, [])])
def test_get_all_companies_data_from_company_table_empty(
    mocker,
    metadata_api: MetadataAPI,
    mock_data: Dict[str, List[Any]],
    expected_result: List[Any],
) -> None:
    """
    Test that `get_all_companies_data_from_company_table()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        mock_data (Dict[str, List[Any]]): The mock response data, simulating an empty dataset.
        expected_result (List[Any]): The expected result, an empty list.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_companies_data_from_company_table()

    mock_request.assert_called_once_with(url=f"{metadata_api.base_url}/v2/companies")
    assert result["data"] == expected_result


@pytest.mark.parametrize("exception_message", ["No access token found"])
def test_get_all_companies_data_from_company_table_failure(
    mocker, metadata_api: MetadataAPI, exception_message: str
) -> None:
    """
    Test that `get_all_companies_data_from_company_table()` raises an exception when `_paginate_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        exception_message (str): The expected exception message.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", side_effect=Exception(exception_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_all_companies_data_from_company_table()

    mock_request.assert_called_once_with(url=f"{metadata_api.base_url}/v2/companies")
    assert exception_message in str(err.value)


@pytest.mark.parametrize(
    "mock_file, table_name, expected_hardware_model",
    [("get_all_inverter_models_data.json", "inverter-model", "Inverter Model 4")],
)
def test_get_all_hardware_models_data_by_table_name_success(
    mocker,
    mock_file: str,
    table_name: str,
    expected_hardware_model: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_all_hardware_models_data_by_table_name()` successfully retrieves and processes hardware model data.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file name containing the expected hardware model data.
        table_name (str): The table name for which hardware model data is requested.
        expected_hardware_model (str): The expected hardware model name.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_hardware_models_data_by_table_name(
        table_name=table_name
    )

    mock_request.assert_called_once_with(url=f"{metadata_api.base_url}/v2/{table_name}")
    assert len(result["data"]) == 4
    assert result["data"][3]["inverter_model"] == expected_hardware_model


@pytest.mark.parametrize(
    "table_name, mock_data, expected_result", [("inverters", {"data": []}, [])]
)
def test_get_all_hardware_models_data_by_table_name_empty(
    mocker,
    metadata_api: MetadataAPI,
    table_name: str,
    mock_data: Dict[str, List[Any]],
    expected_result: List[Any],
) -> None:
    """
    Test that `get_all_hardware_models_data_by_table_name()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        table_name (str): The table name for which hardware model data is requested.
        mock_data (Dict[str, List[Any]]): The mock response data, simulating an empty dataset.
        expected_result (List[Any]): The expected result, an empty list.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_hardware_models_data_by_table_name(
        table_name=table_name
    )

    mock_request.assert_called_once_with(url=f"{metadata_api.base_url}/v2/{table_name}")
    assert result["data"] == expected_result


@pytest.mark.parametrize(
    "table_name, exception_message", [("inverters", "No access token found")]
)
def test_get_all_hardware_models_data_by_table_name_failure(
    mocker, metadata_api: MetadataAPI, table_name: str, exception_message: str
) -> None:
    """
    Test that `get_all_hardware_models_data_by_table_name()` raises an exception when `_paginate_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        table_name (str): The table name for which hardware model data is requested.
        exception_message (str): The expected exception message.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", side_effect=Exception(exception_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_all_hardware_models_data_by_table_name(table_name=table_name)

    mock_request.assert_called_once_with(url=f"{metadata_api.base_url}/v2/{table_name}")
    assert exception_message in str(err.value)


@pytest.mark.parametrize(
    "mock_file, plant_id, expected_company_name",
    [("get_company_data_by_plant_id.json", "3", "Company_10")],
)
def test_get_company_data_by_plant_id_success(
    mocker,
    mock_file: str,
    plant_id: str,
    expected_company_name: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_company_data_by_plant_id()` successfully retrieves company data for a given plant ID.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file name containing the expected company data.
        plant_id (str): The plant ID for which company data is requested.
        expected_company_name (str): The expected company name in the response data.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_single_request", return_value=mock_data
    )

    result = metadata_api.get_company_data_by_plant_id(plant_id=plant_id)

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/plant/{plant_id}/company"
    )
    assert isinstance(result["data"]["company_id"], str)
    assert result["data"]["company_name"] == expected_company_name


@pytest.mark.parametrize("plant_id, mock_data, expected_result", [("1", {}, {})])
def test_get_company_data_by_plant_id_empty(
    mocker,
    metadata_api: MetadataAPI,
    plant_id: str,
    mock_data: Dict[str, Any],
    expected_result: Dict[str, Any],
) -> None:
    """
    Test that `get_company_data_by_plant_id()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        plant_id (int): The plant ID for which company data is requested.
        mock_data (Dict[str, Any]): The mock response data, simulating an empty dataset.
        expected_result (Dict[str, Any]): The expected result, an empty dictionary.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_single_request", return_value=mock_data
    )

    result = metadata_api.get_company_data_by_plant_id(plant_id=plant_id)

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/plant/{plant_id}/company"
    )
    assert result == expected_result


@pytest.mark.parametrize(
    "plant_id, exception_message", [("1", "Company data request failed")]
)
def test_get_company_data_by_plant_id_failure(
    mocker, metadata_api: MetadataAPI, plant_id: str, exception_message: str
) -> None:
    """
    Test that `get_company_data_by_plant_id()` raises an exception when `_single_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        plant_id (int): The plant ID for which company data is requested.
        exception_message (str): The expected exception message.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_single_request", side_effect=Exception(exception_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_company_data_by_plant_id(plant_id=plant_id)

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/plant/{plant_id}/company"
    )
    assert exception_message in str(err.value)


@pytest.mark.parametrize(
    "mock_file, company_id, plant_id, expected_plant_name",
    [
        (
            "get_plant_data_by_company_id_and_plant_id_with_mppt_response.json",
            "1",
            "3",
            "Plant_A",
        )
    ],
)
def test_get_plant_data_by_company_id_and_plant_id_success(
    mocker,
    mock_file: str,
    company_id: str,
    plant_id: str,
    expected_plant_name: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_plant_data_by_company_id_and_plant_id()` successfully retrieves plant data for a given company and
    plant ID.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file name containing the expected plant data.
        company_id (str): The company ID for which plant data is requested.
        plant_id (str): The plant ID for which plant data is requested.
        expected_plant_name (str): The expected plant name in the response data.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_single_request", return_value=mock_data
    )

    result = metadata_api.get_plant_data_by_company_id_and_plant_id(
        company_id=company_id, plant_id=plant_id
    )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}"
    )
    assert result["data"]["plant_id_fk"] == expected_plant_name


@pytest.mark.parametrize(
    "company_id, plant_id, mock_data, expected_result", [("1", "3", {}, {})]
)
def test_get_plant_data_by_company_id_and_plant_id_empty(
    mocker,
    metadata_api: MetadataAPI,
    company_id: str,
    plant_id: str,
    mock_data: Dict[str, Any],
    expected_result: Dict[str, Any],
) -> None:
    """
    Test that `get_plant_data_by_company_id_and_plant_id()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        company_id (str): The company ID for which plant data is requested.
        plant_id (str): The plant ID for which plant data is requested.
        mock_data (Dict[str, Any]): The mock response data, simulating an empty dataset.
        expected_result (Dict[str, Any]): The expected result, an empty dictionary.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_single_request", return_value=mock_data
    )

    result = metadata_api.get_plant_data_by_company_id_and_plant_id(
        company_id=company_id, plant_id=plant_id
    )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}"
    )
    assert result == expected_result


@pytest.mark.parametrize(
    "company_id, plant_id, exception_message", [("1", "3", "Plant data request failed")]
)
def test_get_plant_data_by_company_id_and_plant_id_failure(
    mocker,
    metadata_api: MetadataAPI,
    company_id: str,
    plant_id: str,
    exception_message: str,
) -> None:
    """
    Test that `get_plant_data_by_company_id_and_plant_id()` raises an exception when `_single_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        company_id (str): The company ID for which plant data is requested.
        plant_id (str): The plant ID for which plant data is requested.
        exception_message (str): The expected exception message.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_single_request", side_effect=Exception(exception_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_plant_data_by_company_id_and_plant_id(
            company_id=company_id, plant_id=plant_id
        )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}"
    )
    assert exception_message in str(err.value)


@pytest.mark.parametrize(
    "company_id, plant_id, mock_file, table_name, expected_fields",
    [
        (
            "1",
            "3",
            "get_plant_inverter_table_by_plant_id_with_mppt_response.json",
            "inverter",
            ["plant_id", "inv_id", "inv_id_fk", "inverters_id"],
        ),
        (
            "1",
            "3",
            "get_plant_mppt_table_by_plant_id_response.json",
            "mppt",
            ["plant_id", "mppt_id", "mppt_id_fk", "inv_id"],
        ),
        (
            "1",
            "66",
            "get_plant_string_table_by_plant_id_with_mppt_response.json",
            "string",
            ["plant_id", "string_id", "string_id_fk", "inv_id", "mppt_id"],
        ),
        (
            "1",
            "3",
            "get_plant_orientation_table_by_plant_id_response.json",
            "orientation",
            ["plant_id", "orientation_id", "feb_data", "dec_data"],
        ),
        (
            "1",
            "3",
            "get_plant_sensor_table_by_plant_id_response.json",
            "sensor",
            ["plant_id", "sensor_id", "sensor_id_fk", "irradiance_type", "temp_type"],
        ),
        (
            "1",
            "3",
            "get_plant_attribute_table_by_plant_id_with_mppt_response.json",
            "attribute",
            [
                "plant_id",
                "attributes_id",
                "inv_id",
                "mppt_id",
                "panel_id",
                "orientation_id",
            ],
        ),
        (
            "1",
            "66",
            "get_plant_attribute_table_by_plant_id_with_string_response.json",
            "attribute",
            [
                "plant_id",
                "attributes_id",
                "inv_id",
                "mppt_id",
                "string_id",
                "panel_id",
                "orientation_id",
            ],
        ),
        (
            "1",
            "63",
            "get_plant_attribute_table_by_plant_id_with_tracker_response.json",
            "attribute",
            [
                "plant_id",
                "attributes_id",
                "inv_id",
                "mppt_id",
                "panel_id",
                "orientation_id",
                "tracker_id",
            ],
        ),
        (
            "1",
            "63",
            "get_plant_tracker_table_by_plant_id_response.json",
            "tracker",
            ["tracker_id", "plant_id", "tracker_type"],
        ),
    ],
)
def test_get_plant_metadata_table_by_plant_id_success(
    mocker,
    company_id: str,
    plant_id: str,
    mock_file: str,
    table_name: str,
    expected_fields: List[str],
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_plant_metadata_table_by_plant_id()` successfully retrieves metadata for a given plant ID.

    Args:
        mocker: Pytest mocker fixture.
        company_id (str): The company ID.
        plant_id (str): The plant ID.
        mock_file (str): The mock file containing the expected plant metadata.
        table_name (str): The metadata table name.
        expected_fields (List[str]): The expected fields in the response data.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_plant_metadata_table_by_plant_id(
        company_id=company_id, plant_id=plant_id, table_name=table_name
    )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s"
    )
    assert len(result["data"]) > 0

    for item in result["data"]:
        for field in expected_fields:
            assert isinstance(item[field], str)
            assert item[field] is not None


@pytest.mark.parametrize(
    "company_id, plant_id, table_name, mock_data, expected_data",
    [
        ("1", "3", "inverter", {"data": []}, []),
        ("1", "3", "mppt", {"data": []}, []),
        ("1", "66", "string", {"data": []}, []),
        ("1", "3", "orientation", {"data": []}, []),
        ("1", "3", "sensor", {"data": []}, []),
        ("1", "3", "attribute", {"data": []}, []),
        ("1", "66", "attribute", {"data": []}, []),
        ("1", "63", "attribute", {"data": []}, []),
        ("1", "63", "tracker", {"data": []}, []),
    ],
)
def test_get_plant_metadata_table_by_plant_id_empty(
    mocker,
    company_id: str,
    plant_id: str,
    table_name: str,
    metadata_api: MetadataAPI,
    mock_data: Dict[str, Any],
    expected_data: List[Any],
) -> None:
    """
    Test that `get_plant_metadata_table_by_plant_id()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        company_id (str): The company ID.
        plant_id (str): The plant ID.
        table_name (str): The metadata table name.
        metadata_api (MetadataAPI): The metadata API instance.
        mock_data (Dict[str, Any]): The mock response data, simulating an empty dataset.
        expected_data (List[Any]): The expected result, an empty list.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_plant_metadata_table_by_plant_id(
        company_id=company_id, plant_id=plant_id, table_name=table_name
    )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s"
    )
    assert isinstance(result, dict)
    assert "data" in result and isinstance(result["data"], list)
    assert result["data"] == expected_data


@pytest.mark.parametrize(
    "company_id, plant_id, table_name, expected_error_message",
    [
        ("1", "3", "inverter", "Inverter API failed"),
        ("1", "3", "mppt", "MPPT API failed"),
        ("1", "66", "string", "String API failed"),
        ("1", "3", "orientation", "Orientation API failed"),
        ("1", "3", "sensor", "Sensor API failed"),
        ("1", "3", "attribute", "Attribute API failed"),
        ("1", "66", "attribute", "Attribute API failed"),
        ("1", "63", "attribute", "Attribute API failed"),
        ("1", "63", "tracker", "Tracker API failed"),
    ],
)
def test_get_plant_metadata_table_by_plant_id_failure(
    mocker,
    company_id: str,
    plant_id: str,
    table_name: str,
    expected_error_message: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_plant_metadata_table_by_plant_id()` raises an exception when `_paginate_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        company_id (str): The company ID.
        plant_id (str): The plant ID.
        table_name (str): The metadata table name.
        expected_error_message (str): The expected error message in the raised exception.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", side_effect=Exception(expected_error_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_plant_metadata_table_by_plant_id(
            company_id=company_id, plant_id=plant_id, table_name=table_name
        )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s"
    )
    assert str(err.value) == expected_error_message


@pytest.mark.parametrize(
    "mock_file, company_id, expected_credential_id",
    [("get_all_credentials_data_by_company_id.json", "14", "29")],
)
def test_get_all_credentials_data_by_company_id_success(
    mocker,
    mock_file: str,
    company_id: str,
    expected_credential_id: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_all_credentials_data_by_company_id()` successfully retrieves credentials data for a given company ID.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file name containing expected credentials data.
        company_id (str): The company ID for which credentials data is requested.
        expected_credential_id (str): The expected credential ID in the response data.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_paginate = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_credentials_data_by_company_id(company_id=company_id)

    mock_paginate.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/credentials"
    )

    assert isinstance(result, dict)
    assert isinstance(result["data"], list)
    assert len(result["data"]) == 9
    assert all("credentials_id" in item for item in result["data"])
    assert result["data"][2]["credentials_id"] == expected_credential_id


@pytest.mark.parametrize(
    "company_id, mock_data, expected_result", [("12", {"data": []}, [])]
)
def test_get_all_credentials_data_by_company_id_empty_response(
    mocker,
    metadata_api: MetadataAPI,
    company_id: str,
    mock_data: Dict[str, Any],
    expected_result: List[Any],
) -> None:
    """
    Test that `get_all_credentials_data_by_company_id()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        company_id (str): The company ID for which credentials data is requested.
        mock_data (Dict[str, Any]): The mock response data, simulating an empty dataset.
        expected_result (List[Any]): The expected result, an empty list.
    """
    mock_paginate = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_credentials_data_by_company_id(company_id=company_id)

    assert isinstance(result, dict)
    assert "data" in result and isinstance(result["data"], list)
    assert result["data"] == expected_result

    mock_paginate.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/credentials"
    )


@pytest.mark.parametrize(
    "invalid_company_id, expected_error_message",
    [("999", "Company with ID 999 does not exist or has been deleted.")],
)
def test_get_all_credentials_data_by_company_id_failure(
    mocker,
    invalid_company_id: str,
    expected_error_message: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_all_credentials_data_by_company_id()` raises an exception when `_paginate_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        invalid_company_id (str): An invalid company ID to simulate an error.
        expected_error_message (str): The expected error message in the raised exception.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_paginate = mocker.patch.object(
        metadata_api, "_paginate_request", side_effect=Exception(expected_error_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_all_credentials_data_by_company_id(
            company_id=invalid_company_id
        )

    mock_paginate.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{invalid_company_id}/credentials"
    )
    assert str(err.value) == expected_error_message


@pytest.mark.parametrize(
    "mock_file, company_id, expected_plant_name, expected_plant_count",
    [("get_all_plants_data_by_company_id_response.json", "1", "Plant_B", 3)],
)
def test_get_all_plants_data_by_company_id_success(
    mocker,
    mock_file: str,
    company_id: str,
    expected_plant_name: str,
    expected_plant_count: int,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_all_plants_data_by_company_id()` successfully retrieves plant data for a given company ID.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file containing expected plant data.
        company_id (str): The company ID for which plant data is requested.
        expected_plant_name (str): The expected plant name in the response data.
        expected_plant_count (int): The expected number of plants in the response.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_plants_data_by_company_id(company_id=company_id)

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants"
    )

    assert isinstance(result, dict)
    assert isinstance(result["data"], list)
    assert len(result["data"]) == expected_plant_count
    assert all("plant_id_fk" in item for item in result["data"])
    assert result["data"][1]["plant_id_fk"] == expected_plant_name


@pytest.mark.parametrize(
    "company_id, mock_data, expected_result", [("1", {"data": []}, [])]
)
def test_get_all_plants_data_by_company_id_empty(
    mocker,
    metadata_api: MetadataAPI,
    company_id: str,
    mock_data: Dict[str, Any],
    expected_result: List[Any],
) -> None:
    """
    Test that `get_all_plants_data_by_company_id()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        company_id (str): The company ID for which plant data is requested.
        mock_data (Dict[str, Any]): The mock response data, simulating an empty dataset.
        expected_result (List[Any]): The expected result, an empty list.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", return_value=mock_data
    )

    result = metadata_api.get_all_plants_data_by_company_id(company_id=company_id)

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants"
    )
    assert isinstance(result, dict)
    assert "data" in result and isinstance(result["data"], list)
    assert result["data"] == expected_result


@pytest.mark.parametrize(
    "company_id, expected_error_message",
    [
        ("1", "Plant data API failed for company ID 1"),
        ("999", "Plant data API failed for company ID 999"),
    ],
)
def test_get_all_plants_data_by_company_id_failure(
    mocker, company_id: str, expected_error_message: str, metadata_api: MetadataAPI
) -> None:
    """
    Test that `get_all_plants_data_by_company_id()` raises an exception when `_paginate_request()` fails.

    Args:
        mocker: Pytest mocker fixture.
        company_id (str): The company ID for which plant data is requested.
        expected_error_message (str): The expected error message in the raised exception.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_paginate_request", side_effect=Exception(expected_error_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_all_plants_data_by_company_id(company_id=company_id)

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants"
    )
    assert str(err.value) == expected_error_message


@pytest.mark.parametrize(
    "mock_file, company_id, plant_id, table_name, table_id, expected_field, expected_value",
    [
        (
            "get_plant_inverter_table_by_plant_id_with_mppt_response.json",
            "1",
            "3",
            "inverter",
            "12",
            "inv_id_fk",
            "inv_id_fk_2",
        ),
        (
            "get_plant_mppt_table_by_plant_id_response.json",
            "1",
            "3",
            "mppt",
            "14",
            "mppt_id_fk",
            "mppt_2",
        ),
        (
            "get_plant_string_table_by_plant_id_with_mppt_response.json",
            "1",
            "66",
            "string",
            "320",
            "string_id_fk",
            "Str02",
        ),
    ],
)
def test_get_plant_metadata_by_plant_id_table_name_and_table_id_success(
    mocker,
    mock_file: str,
    company_id: str,
    plant_id: str,
    table_name: str,
    table_id: str,
    expected_field: str,
    expected_value: str,
    metadata_api: MetadataAPI,
) -> None:
    """
    Test that `get_plant_metadata_by_plant_id_table_name_and_table_id()` successfully retrieves metadata for a
    specific plant table ID.

    Args:
        mocker: Pytest mocker fixture.
        mock_file (str): The mock file containing expected metadata.
        company_id (str): The company ID.
        plant_id (str): The plant ID.
        table_name (str): The metadata table name.
        table_id (str): The specific table ID being requested.
        expected_field (str): The field expected in the response data.
        expected_value (str): The expected value for the given field.
        metadata_api (MetadataAPI): The metadata API instance.
    """
    mock_data = load_mock_data(mock_file)

    mock_request = mocker.patch.object(
        metadata_api, "_single_request", return_value=mock_data
    )

    result = metadata_api.get_plant_metadata_by_plant_id_table_name_and_table_id(
        company_id=company_id,
        plant_id=plant_id,
        table_name=table_name,
        table_id=table_id,
    )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s/{table_id}"
    )

    assert isinstance(result, dict)
    assert isinstance(result["data"], list)
    assert expected_field in result["data"][1]
    assert result["data"][1][expected_field] == expected_value


@pytest.mark.parametrize(
    "company_id, plant_id, table_name, table_id, mock_data, expected_result",
    [
        ("1", "101", "inverter", "1024", {}, {}),
        ("1", "101", "mppt", "2023", {}, {}),
        ("1", "101", "string", "3", {}, {}),
    ],
)
def test_get_plant_metadata_by_plant_id_table_name_and_table_id_empty(
    mocker,
    metadata_api: MetadataAPI,
    company_id: str,
    plant_id: str,
    table_name: str,
    table_id: str,
    mock_data: Dict[str, Any],
    expected_result: Dict[str, Any],
) -> None:
    """
    Test that `get_plant_metadata_by_plant_id_table_name_and_table_id()` correctly handles an empty response.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        company_id (str): The company ID.
        plant_id (str): The plant ID.
        table_name (str): The metadata table name.
        table_id (str): The specific table ID being requested.
        mock_data (Dict[str, Any]): The mock response data, simulating an empty dataset.
        expected_result (Dict[str, Any]): The expected result, an empty dictionary.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_single_request", return_value=mock_data
    )

    result = metadata_api.get_plant_metadata_by_plant_id_table_name_and_table_id(
        company_id=company_id,
        plant_id=plant_id,
        table_name=table_name,
        table_id=table_id,
    )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s/{table_id}"
    )

    assert isinstance(result, dict)
    assert result == expected_result


@pytest.mark.parametrize(
    "company_id, plant_id, table_name, table_id, expected_error_message",
    [
        (
            "32",
            "100",
            "inverter",
            "1086",
            "Plant with ID 100 and Company ID 32 does not exist or has been deleted.",
        ),
        (
            "26",
            "86",
            "mppt",
            "4588",
            "Plant with ID 86 and Company ID 26 does not exist or has been deleted.",
        ),
        (
            "32",
            "100",
            "string",
            "3692",
            "Plant with ID 100 and Company ID 32 does not exist or has been deleted.",
        ),
    ],
)
def test_get_plant_metadata_by_plant_id_table_name_and_table_id_failure(
    mocker,
    metadata_api: MetadataAPI,
    company_id: str,
    plant_id: str,
    table_name: str,
    table_id: str,
    expected_error_message: str,
) -> None:
    """
    Test that `get_plant_metadata_by_plant_id_table_name_and_table_id()` raises an exception when `_single_request()`
    fails.

    Args:
        mocker: Pytest mocker fixture.
        metadata_api (MetadataAPI): The metadata API instance.
        company_id (str): The company ID.
        plant_id (str): The plant ID.
        table_name (str): The metadata table name.
        table_id (str): The specific table ID being requested.
        expected_error_message (str): The expected error message in the raised exception.
    """
    mock_request = mocker.patch.object(
        metadata_api, "_single_request", side_effect=Exception(expected_error_message)
    )

    with pytest.raises(Exception) as err:
        metadata_api.get_plant_metadata_by_plant_id_table_name_and_table_id(
            company_id=company_id,
            plant_id=plant_id,
            table_name=table_name,
            table_id=table_id,
        )

    mock_request.assert_called_once_with(
        url=f"{metadata_api.base_url}/v2/companies/{company_id}/plants/{plant_id}/{table_name}s/{table_id}"
    )

    assert str(err.value) == expected_error_message
