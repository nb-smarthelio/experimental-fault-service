import logging

import pandas as pd

logger = logging.getLogger(__name__)


class TimestreamPivotTransformer:
    """
    A class to transform time-series data into a pivoted multilevel column DataFrame.

    Parameters:
    -----------
    data : pd.DataFrame
        The input data to be transformed.

    Example DataFrame structure:
        +-----------------------+-----+------+-------+-----+------+-----+-----+-----+------+
        | datetime              | Inv | MPPT | String | P   | Tamb | V   | G   | I   | Tmod |
        +-----------------------+-----+------+-------+-----+------+-----+-----+-----+------+
        | 2023-03-01 00:00:00   | 276 | 911 |  Nan  | 0.0 | -2.92| 0.0 | -1.0| 0.0 | -7.08 |
        | 2023-03-01 00:05:00   | 276 | 911 |  Nan  | 0.0 | -2.86| 0.0 | -1.0| 0.0 | -7.28 |
        | ...                   | ... | ... | ...   | ... | ...  | ... | ... | ... | ...   |
        | 2023-03-01 23:50:00   | 282 | 924 | Nan   | 0.0 | -4.18| 0.0 | -1.0| 0.0 | -8.12 |
        | 2023-03-01 23:55:00   | 282 | 924 | Nan   | 0.0 | -4.20| 0.0 | -1.0| 0.0 | -8.22 |
        +-----------------------+-----+------+-------+-----+------+-----+-----+-----+------+

    Methods:
    --------
    transform()
        Transforms the data into pivoted and ordered DataFrames for inverter and meteorological data.

    Returns:
    --------
    inverter_data : pandas.DataFrame
        The transformed inverter data.

        +--------------------------+-----+-----+------+------+-----+-----+
        | ag_level_1               | 276 | 276 | 276  | 276  | 276 | 276 |
        | ag_level_0               | 911 | 911 | 911  | 911  | 912 | 912 |
        | curve                    | I   | P   | P-AC | V    | I   |  P  |
        | datetime                 |     |     |      |      |     |     |
        +--------------------------+-----+-----+------+------+-----+-----+
        | 2023-11-05 01:00:00+01:00|  0  |  0  |  0   |  0   |  0  |  0  |
        | 2023-11-05 01:15:00+01:00|  0  |  0  |  0   |  0   |  0  |  0  |
        | 2023-11-05 01:30:00+01:00|  0  |  0  |  0   |  0   |  0  |  0  |
        | 2023-11-05 01:45:00+01:00|  0  |  0  |  0   |  0   |  0  |  0  |
        | 2023-11-05 02:00:00+01:00|  0  |  0  |  0   |  0   |  0  |  0  |
        +--------------------------+-----+-----+------+------+-----+-----+

    meteo_data : pandas.DataFrame
        The transformed meteorological data.

        +--------------------------+-----+-----+------+------+----+
        | ag_level_1               | 276 | 276 | 276  | 276 | 276 |
        | ag_level_0               | 911 | 911 | 911  | 912 | 912 |
        | curve                    | G   | Tmod| Tamb | G  | Tmod |
        | datetime                 |     |     |      |     |     |
        +--------------------------+-----+-----+------+------+----+
        | 2023-11-05 01:00:00+01:00|  0  |  0  |  0   |  0   |  0 |
        | 2023-11-05 01:15:00+01:00|  0  |  0  |  0   |  0   |  0 |
        | 2023-11-05 01:30:00+01:00|  0  |  0  |  0   |  0   |  0 |
        | 2023-11-05 01:45:00+01:00|  0  |  0  |  0   |  0   |  0 |
        | 2023-11-05 02:00:00+01:00|  0  |  0  |  0   |  0   |  0 |
        +--------------------------+-----+-----+------+------+----+

    Example:
    --------
    data = pd.DataFrame(...)  # Assume data is a properly formatted DataFrame
    transformer = TimestreamPivotTransformer(data)
    inverter_data, meteo_data = transformer.transform()
    """

    DEFAULT_INV_COL_NAMES: list[str] = ["I", "P", "V", "P-AC"]
    DEFAULT_METEO_COL_NAMES: list[str] = ["G", "Tmod", "Tamb"]
    DEFAULT_LEVELS_COL_NAMES: list[str] = ["Inv", "MPPT", "CB", "String"]
    DATETIME_COLUMN_NAME: str = "datetime"
    FEATURE_LEVEL_NAME: str = "curve"

    def __init__(self, data: pd.DataFrame):
        """
        Initialize the TimestreamTransformer with provided data.

        Parameters:
        -----------
        data : pd.DataFrame
            The DataFrame containing the time-series data to be transformed.

        Raises:
        -------
        ValueError
            If the provided data is empty.
        """
        if data.empty:
            raise ValueError("Provided data for transformation is empty.")
        self.data = data.copy()
        self.inv_col_names = self.DEFAULT_INV_COL_NAMES
        self.meteo_col_names = self.DEFAULT_METEO_COL_NAMES
        self.levels_col_names = self.DEFAULT_LEVELS_COL_NAMES
        self.aggregation_levels = self._check_columns_and_assign_aggregation_levels()

    @property
    def aggregation_level_names(self) -> list[str]:
        """
        Get the names of the aggregation levels in the DataFrame.
        That is, the names of the columns that are used to pivot the data.

        Returns:
        --------
        list[str]
            The names of the aggregation levels in the DataFrame.
        """
        return list(self.aggregation_levels.values())[::-1]

    def _check_columns_and_assign_aggregation_levels(self) -> dict:
        """
        Check and assign aggregation levels based on the data columns.
        Aggregation levels are assigned in the order of the levels_col_names.
        Inv -> MPPT -> CB -> String : ag_level_3 -> ag_level_2 -> ag_level_1 -> ag_level_0

        Returns:
        --------
        dict
            A dictionary containing the aggregation levels and their corresponding column names.
            e.g., {"Inv": "ag_level_3", "MPPT": "ag_level_2", ...}
        """
        columns_in_order = self.levels_col_names[::-1]
        aggregation_levels = {}
        for column in columns_in_order:
            if column in self.data.columns and not self.data[column].eq("").any():
                aggregation_levels[column] = f"ag_level_{len(aggregation_levels)}"
            else:
                logger.warning(
                    f"Column {column} does not exist in the DataFrame or contains empty values."
                )
        return aggregation_levels

    def _rename_columns_based_on_levels(self) -> pd.DataFrame:
        """
        Rename columns of long-format DataFrame based on the aggregation levels.
        E.g., Inv -> ag_level_3, MPPT -> ag_level_2, etc.

        Returns:
        --------
        pandas.DataFrame
            The DataFrame with renamed columns based on the aggregation levels.
        """
        self.data_to_transform = self.data.copy()
        for column, ag_level in self.aggregation_levels.items():
            self.data_to_transform[ag_level] = self.data_to_transform[column].astype(
                str
            )
            self.data_to_transform.drop(columns=column, inplace=True)
        return self.data_to_transform

    def _pivot_data(self, column_names: list[str]) -> pd.DataFrame:
        """
        Pivot the data based on the provided column names.

        Parameters:
        -----------
        column_names : list[str]
            The column names to pivot the data on.

        Returns:
        --------
        pandas.DataFrame
            The pivoted DataFrame with a MultiIndex on the columns.
        """
        value_cols = [col for col in column_names if col in self.data.columns]
        data_to_pivot = self.data_to_transform[
            self.aggregation_level_names + value_cols
        ]
        data_to_pivot = data_to_pivot.reset_index()
        data_to_pivot.set_index(
            self.aggregation_level_names + [self.DATETIME_COLUMN_NAME], inplace=True
        )

        # Unstack the DataFrame to create a MultiIndex on the columns
        multi_index_df = data_to_pivot.unstack(
            list(range(len(self.aggregation_level_names)))
        )
        return multi_index_df

    def _rename_and_reorder_levels(self, data: pd.DataFrame) -> pd.DataFrame:
        """
        Rename and reorder the levels of the DataFrame.
        "Inv" -> "ag_level_3", "MPPT" -> "ag_level_2", etc.
        Columns are reordered to have the "curve" level as the last level.

        Parameters:
        -----------
        data : pandas.DataFrame
            The DataFrame to rename and reorder the levels.

        Returns:
        --------
        pandas.DataFrame
            The DataFrame with renamed and reordered levels
        """
        data.rename_axis(
            [self.FEATURE_LEVEL_NAME, *self.aggregation_level_names],
            axis=1,
            inplace=True,
        )
        data = data.reorder_levels(
            [*self.aggregation_level_names, self.FEATURE_LEVEL_NAME], axis=1
        )
        data.sort_index(axis=1, inplace=True)
        return data

    def transform(self) -> tuple[pd.DataFrame, pd.DataFrame]:
        """
        Transform the data into pivoted and ordered DataFrames for inverter and meteorological data.
        1. Rename columns based on the aggregation levels.
        2. Pivot the data based on the inverter and meteorological column names.
        3. Rename and reorder the levels of the DataFrame.

        Returns:
        --------
        inverter_data : pandas.DataFrame
            The transformed inverter data.
        meteo_data : pandas.DataFrame
            The transformed meteorological data.
        """
        self._rename_columns_based_on_levels()
        inverter_data = self._pivot_data(self.inv_col_names)
        meteo_data = self._pivot_data(self.meteo_col_names)
        inverter_data = self._rename_and_reorder_levels(inverter_data)
        meteo_data = self._rename_and_reorder_levels(meteo_data)
        logger.info("Data transformation completed.")
        return inverter_data, meteo_data
