from .outlier_thresholds import (
    IRRAD_LOW,
    IRRAD_HIGH,
    TAMB_LOW,
    TAMB_HIGH,
    TMOD_LOW,
    TMOD_HIGH,
    CURRENT_FACTOR,
)
import pandas as pd


class DataSanitizer:
    """
    The DataSanitizer class is designed to sanitize meteo and inverter data by applying a set of
    predefined filters to remove outliers based on various thresholds.
    ...
    """

    def __init__(
        self,
        *,
        meteo_data: pd.DataFrame = None,
        inverter_data: pd.DataFrame = None,
        array_info: pd.DataFrame = None,
    ):
        self._meteo_data = meteo_data
        self._inverter_data = inverter_data
        self._array_info = array_info
        self.removed_indices = {"meteo": {}, "inverter": {}}

    @property
    def meteo_data(self):
        return self._meteo_data

    @meteo_data.setter
    def meteo_data(self, data):
        self._meteo_data = data

    @property
    def inverter_data(self):
        return self._inverter_data

    @inverter_data.setter
    def inverter_data(self, data):
        self._inverter_data = data

    @property
    def array_info(self):
        return self._array_info

    @array_info.setter
    def array_info(self, data):
        self._array_info = data

    def _filter_data(
        self, data: pd.DataFrame, key: str, low: float, high: float
    ) -> pd.DataFrame:
        if key not in data.columns.get_level_values("curve"):
            # Optionally, log a warning here
            print(
                f"Warning: Key '{key}' not present in the dataframe's multi-index. Skipping filter."
            )
            return data  # Return the unmodified data

        filtered_data = data.xs(key, axis=1, level="curve")

        # Create mask for values within the desired range
        mask_df = (filtered_data.ge(low)) & (filtered_data.le(high))

        # Create mask for NaN values
        nan_mask = filtered_data.isna()

        # Adjust the mask to treat NaN values as True
        combined_mask = (mask_df | nan_mask).all(axis=1)

        return data[combined_mask]

    def apply_filters(self, filter_registry, data_attr):
        data = getattr(self, data_attr)
        removed_indices = {}

        for filter_name, filter_params in filter_registry.items():
            original_data = data.copy()
            data = self._filter_data(data, **filter_params)
            removed_data = original_data.drop(data.index)
            removed_indices[filter_name] = removed_data.index

        self.removed_indices[data_attr] = removed_indices
        setattr(self, data_attr, data)
        return removed_indices

    def apply_all_filters(self):
        meteo_filters = {
            "Irradiance": {"key": "G", "low": IRRAD_LOW, "high": IRRAD_HIGH},
            "Ambient_Temperature": {"key": "Tamb", "low": TAMB_LOW, "high": TAMB_HIGH},
            "Module_Temperature": {"key": "Tmod", "low": TMOD_LOW, "high": TMOD_HIGH},
        }
        inverter_filters = {
            "Current": {
                "key": "I",
                "low": 0,
                "high": CURRENT_FACTOR
                * self.array_info.xs("i_sc", axis=1)
                * self.array_info.xs("number_of_strings", axis=1),
            },
            "Voltage": {
                "key": "V",
                "low": 0,
                "high": self.array_info.xs("v_oc", axis=1)
                * self.array_info.xs("modules_per_string", axis=1),
            },
        }

        self.apply_filters(meteo_filters, "_meteo_data")
        self.apply_filters(inverter_filters, "_inverter_data")

        # Return the sanitized dataframes
        return self._inverter_data, self._meteo_data

    def get_removed_counts(self):
        counts_removed = {}
        for data_type, filters in self.removed_indices.items():
            for filter_name, indices in filters.items():
                counts_removed[filter_name] = len(indices)
        return counts_removed

    def get_removed_indices(self):
        return self.removed_indices
