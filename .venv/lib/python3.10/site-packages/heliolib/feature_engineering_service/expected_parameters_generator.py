import numpy as np
import pandas as pd
from heliolib.utils import add_index_curve_level
from typing import Dict
import logging

logger = logging.getLogger(__name__)


class ExpectedParametersGenerator:
    BASELINE_IRRADIANCE_STC = 1000
    BASELINE_IRRADIANCE_NOCT = 800
    SYSTEM_AGE_TO_BE_OLDER = 1
    DEFAULT_NOCT_TO_STC_RATIO = 0.7421

    KEYS_TO_BE_VALIDATED = [
        "impp_noct",
        "number_of_strings",
        "wattage_noct",
        "modules_per_string",
        "i_mpp",
        "panel_wattage",
        "degrdn_yr1",
        "degrdn_yr2",
    ]

    COMPUTATION_PIPELINE = {
        ("NOCT", "power"): ("_expected_power_noct", "P_exp_noct"),
        ("NOCT", "power_degradation"): (
            "_expected_power_after_degradation",
            "P_exp_noct_degradation",
        ),
        ("NOCT", "current"): ("_expected_current_noct", "I_exp_noct"),
        ("NOCT", "voltage"): ("_expected_voltage_noct", "V_exp_noct"),
        ("NOCT", "energy_degradation"): (
            "_expected_energy_noct",
            "E_exp_noct_degradation",
        ),
        ("NOCT", "clearsky_energy_degradation"): (
            "_expected_energy_noct_clearsky",
            "E_exp_noct_degradation_clearsky",
        ),
        ("NOCT", "power_degradation_clearsky"): (
            "_expected_power_after_degradation_clearsky",
            "P_exp_noct_degradation_clearsky",
        ),
        ("STC", "power"): ("_expected_power_stc", "P_exp_stc"),
        ("STC", "current"): ("_expected_current_stc", "I_exp_stc"),
        ("STC", "voltage"): ("_expected_voltage_stc", "V_exp_stc"),
    }

    def __init__(
        self,
        meteo_data: pd.DataFrame,
        array_info: pd.DataFrame,
        system_age: float,
        irradiance_key: str = "G",
    ):

        logger.warning("irradiance_key set to G as default")
        self.array_info = array_info
        self.system_age = system_age
        self.irradiance_key = irradiance_key
        self.irradiance = None
        self._intermediate_cache = {}
        self.include_inverter_efficiency = None

        self._extract_irradiance(meteo_data)
        self._detect_fallback_mode()
        self._validate_inputs()
        del meteo_data

    def _extract_irradiance(self, meteo_data: pd.DataFrame):
        if self.irradiance_key in meteo_data.columns.get_level_values(level="curve"):
            self.irradiance = meteo_data.xs(self.irradiance_key, axis=1, level="curve")
        else:
            raise ValueError(
                f"Irradiance key '{self.irradiance_key}' not found in meteo data."
            )

    def _detect_fallback_mode(self):
        missing_keys = [
            k
            for k in [
                "panel_wattage",
                "modules_per_string",
                "number_of_strings",
                "wattage_noct",
            ]
            if k not in self.array_info.columns
        ]
        self.use_dc_capacity = bool(missing_keys)
        if self.use_dc_capacity:
            if (
                "dc_capacity" not in self.array_info.columns
                or self.array_info["dc_capacity"].isna().any()
                or (self.array_info["dc_capacity"] == 0).any()
            ):
                raise ValueError("Fallback failed: missing or invalid 'dc_capacity'.")
            logger.warning(
                "Fallback mode triggered: using 'dc_capacity' and 'inverter_eff'."
            )
            if "noct_wattage_stc_wattage_ratio" in self.array_info.columns:
                self.noct_to_stc_ratio = self.array_info[
                    "noct_wattage_stc_wattage_ratio"
                ]
            else:
                self.noct_to_stc_ratio = pd.Series(
                    self.DEFAULT_NOCT_TO_STC_RATIO, index=self.array_info.index
                )

    def _validate_inputs(self):
        self._validate_array_info(self.KEYS_TO_BE_VALIDATED)
        self._validate_irradiance()
        if self.system_age < 0:
            raise ValueError("system_age must be a non-negative.")

    def _validate_irradiance(self):
        if (self.irradiance.isnull() | (self.irradiance <= 0)).all().all():
            raise ValueError("Irradiance dataframe cannot be completely null or zero.")

    def _validate_array_info(self, keys: list):
        for key in keys:
            if key in self.array_info.columns and (
                self.array_info[key].isna().any() or (self.array_info[key] == 0).any()
            ):
                raise ValueError(f"Invalid array_info for key: {key}")

    def _expected_current_noct(self) -> pd.DataFrame:
        if "I_exp_noct" not in self._intermediate_cache:
            # raise if impp_noct is not in array_info
            if (
                "impp_noct" not in self.array_info.columns
                or self.array_info["impp_noct"].isna().any()
                or (self.array_info["impp_noct"] == 0).any()
            ):
                raise ValueError("impp_noct is not in array_info")
            self._intermediate_cache["I_exp_noct"] = (
                self.array_info["impp_noct"]
                * self.array_info["number_of_strings"]
                * self.irradiance
                / self.BASELINE_IRRADIANCE_NOCT
            )
        return self._intermediate_cache["I_exp_noct"]

    def _expected_power_noct(self) -> pd.DataFrame:
        key = ("P_exp_noct", self.include_inverter_efficiency)
        if key not in self._intermediate_cache:
            base_power = self._get_effective_power("NOCT")
            self._intermediate_cache[key] = (
                base_power * self.irradiance / self.BASELINE_IRRADIANCE_NOCT
            )
        return self._intermediate_cache[key]

    def _expected_power_after_degradation(self) -> pd.DataFrame:
        key = ("P_exp_noct_degradation", self.include_inverter_efficiency)
        if key not in self._intermediate_cache:
            base_power = self._expected_power_noct()
            degradation = self._expected_degradation()
            self._intermediate_cache[key] = base_power * (1 - degradation)
        return self._intermediate_cache[key]

    def _expected_power_after_degradation_clearsky(
        self, clearsky_irradiance: pd.DataFrame
    ) -> pd.DataFrame:
        key = ("P_exp_noct_degradation_clearsky", self.include_inverter_efficiency)
        if key not in self._intermediate_cache:
            base_power = self._get_effective_power("NOCT")
            degraded = base_power * clearsky_irradiance / self.BASELINE_IRRADIANCE_NOCT
            degradation = self._expected_degradation()
            self._intermediate_cache[key] = degraded * (1 - degradation)
        return self._intermediate_cache[key]

    def _expected_energy_noct(self, data_frequency_minutes: int) -> pd.DataFrame:
        power_df = self._expected_power_after_degradation()
        delta_t = data_frequency_minutes / 60
        return 0.5 * (power_df + power_df.shift(1).fillna(0)) * delta_t

    def _expected_energy_noct_clearsky(
        self, clearsky_irradiance: pd.DataFrame, data_frequency_minutes: int
    ) -> pd.DataFrame:
        power_df = self._expected_power_after_degradation_clearsky(clearsky_irradiance)
        delta_t = data_frequency_minutes / 60
        return 0.5 * (power_df + power_df.shift(1).fillna(0)) * delta_t

    def _expected_voltage_noct(self) -> pd.DataFrame:
        if "V_exp_noct" not in self._intermediate_cache:
            current = self._expected_current_noct()
            power = self._expected_power_noct()
            current = current.replace(0, np.nan)
            self._intermediate_cache["V_exp_noct"] = power / current
        return self._intermediate_cache["V_exp_noct"]

    def _expected_current_stc(self) -> pd.DataFrame:
        if "I_exp_stc" not in self._intermediate_cache:
            if (
                "i_mpp" not in self.array_info.columns
                or self.array_info["i_mpp"].isna().any()
                or (self.array_info["i_mpp"] == 0).any()
            ):
                raise ValueError("i_mpp is not in array_info")
            self._intermediate_cache["I_exp_stc"] = (
                self.array_info["i_mpp"]
                * self.array_info["number_of_strings"]
                * self.irradiance
                / self.BASELINE_IRRADIANCE_STC
            )
        return self._intermediate_cache["I_exp_stc"]

    def _expected_power_stc(self) -> pd.DataFrame:
        if "P_exp_stc" not in self._intermediate_cache:
            base_power = self._get_effective_power("STC")
            self._intermediate_cache["P_exp_stc"] = (
                base_power * self.irradiance / self.BASELINE_IRRADIANCE_STC
            )
        return self._intermediate_cache["P_exp_stc"]

    def _expected_voltage_stc(self) -> pd.DataFrame:
        if "V_exp_stc" not in self._intermediate_cache:
            current = self._expected_current_stc()
            power = self._expected_power_stc()
            current = current.replace(0, np.nan)
            self._intermediate_cache["V_exp_stc"] = power / current
        return self._intermediate_cache["V_exp_stc"]

    def _expected_degradation(self) -> pd.Series:
        if "degradation" not in self._intermediate_cache:
            if self.system_age > self.SYSTEM_AGE_TO_BE_OLDER:
                if (
                    "degrdn_yr1" not in self.array_info.columns
                    or self.array_info["degrdn_yr1"].isna().any()
                    or (self.array_info["degrdn_yr1"] == 0).any()
                    or "degrdn_yr2" not in self.array_info.columns
                    or self.array_info["degrdn_yr2"].isna().any()
                    or (self.array_info["degrdn_yr2"] == 0).any()
                ):
                    raise ValueError("degrdn_yr1 or degrdn_yr2 is not in array_info")
                degradation = self.array_info["degrdn_yr1"] / 100 + (
                    self.array_info["degrdn_yr2"] / 100
                ) * (self.system_age - 1)
            else:
                degradation = self.array_info["degrdn_yr1"] / 100
            self._intermediate_cache["degradation"] = degradation
        return self._intermediate_cache["degradation"]

    @staticmethod
    def extract_clearsky_irradiance(
        clearsky_data: pd.DataFrame, clearsky_key: str = "Gcsky"
    ) -> pd.DataFrame:
        if clearsky_key in clearsky_data.columns.get_level_values(level="curve"):
            return clearsky_data.xs(clearsky_key, axis=1, level="curve")
        else:
            raise ValueError(f"Clearsky key '{clearsky_key}' not found.")

    @staticmethod
    def get_key_value_from_config(config: Dict, key: str) -> bool:
        """
        Get the value of a given key from the config dictionary based on the conditions 'NOCT' or 'STC'.
        If the key exists and has a True value under any condition, return True. Otherwise, return False.

        Parameters:
            config (dict): The configuration dictionary.
            key (str): The key to search for.

        Returns:
            bool: True if the key exists with a True value in either 'STC' or 'NOCT', False otherwise.

        Raises:
            ValueError: If the key does not exist in either 'NOCT' or 'STC' condition.
        """
        # Check if the key exists in either 'NOCT' or 'STC'
        for condition in ["NOCT", "STC"]:
            if condition in config and key in config[condition]:
                if config[condition][key]:
                    return True

        # If the key was not found with True value in either condition, return False
        return False

    def validate_method_arguments(
        self,
        config,
        data_frequency_minutes,
        clearsky_data,
        clearsky_key,
        include_inverter_efficiency,
    ):
        if not isinstance(config, dict):
            raise ValueError("config must be a dictionary.")
        if not isinstance(data_frequency_minutes, int):
            raise ValueError("data_frequency_minutes must be int.")
        if clearsky_data is not None and not isinstance(clearsky_data, pd.DataFrame):
            raise ValueError("clearsky_data must be a DataFrame.")
        if not isinstance(clearsky_key, str):
            raise ValueError("clearsky_key must be string.")
        if not isinstance(include_inverter_efficiency, bool):
            raise ValueError("include_inverter_efficiency must be bool.")

    def _get_effective_power(self, condition: str) -> pd.Series:
        if self.use_dc_capacity:
            eff = (
                self.array_info["inverter_eff"]
                if self.include_inverter_efficiency
                else 1.0
            )
            return self.array_info["dc_capacity"] * eff
        if condition == "STC":
            return (
                self.array_info["panel_wattage"]
                * self.array_info["modules_per_string"]
                * self.array_info["number_of_strings"]
            )
        else:
            return (
                self.array_info["wattage_noct"]
                * self.array_info["modules_per_string"]
                * self.array_info["number_of_strings"]
            )

    def generate_expected_features(
        self,
        config: dict,
        data_frequency_minutes: int,
        clearsky_data: pd.DataFrame = None,
        clearsky_key: str = "Gcsky",
        include_inverter_efficiency: bool = True,
    ) -> pd.DataFrame:

        self.validate_method_arguments(
            config,
            data_frequency_minutes,
            clearsky_data,
            clearsky_key,
            include_inverter_efficiency,
        )
        self.include_inverter_efficiency = include_inverter_efficiency

        expected_params_list = []
        if clearsky_data is not None and not clearsky_data.index.equals(
            self.irradiance.index
        ):
            logger.info(
                f"Mismatch in timestamps of clearsky_data and measured_irradiance, clearsky={clearsky_data.index} and measure_irradiance={self.irradiance.index}"
            )
            clearsky_data = clearsky_data.loc[self.irradiance.index]
        clearsky_irradiance = (
            self.extract_clearsky_irradiance(clearsky_data, clearsky_key)
            if clearsky_data is not None
            and self.get_key_value_from_config(
                config=config, key="clearsky_energy_degradation"
            )
            else None
        )

        for (mode, param_type), (
            method_name,
            base_label,
        ) in self.COMPUTATION_PIPELINE.items():
            if not config.get(mode, {}).get(param_type, False):
                continue

            method = getattr(self, method_name)
            args = []
            if "clearsky" in param_type:
                if clearsky_irradiance is None:
                    logger.warning(
                        f"Skipping {base_label} calculation because clearsky_data is not provided."
                    )
                    continue
                args.append(clearsky_irradiance)
            if "energy" in param_type:
                args.append(data_frequency_minutes)

            result = method(*args)
            expected_params_list.append(
                add_index_curve_level(result.copy(), base_label)
            )

        if not expected_params_list:
            logger.warning("No expected parameters were calculated.")
            return pd.DataFrame(index=self.irradiance.index)

        return pd.concat(expected_params_list, axis=1).astype(float)
