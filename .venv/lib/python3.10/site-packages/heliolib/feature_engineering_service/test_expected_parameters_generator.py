import logging

import pandas as pd
import pytest

from heliolib.feature_engineering_service.expected_parameters_generator import (
    ExpectedParametersGenerator,
)
from heliolib.feature_engineering_service.read_mock_csv_data_as_pandas_dataframe import (
    fetch_all_valid_dataframes_l1_data,
    fetch_all_valid_dataframes_with_complete_data,
)


@pytest.mark.parametrize(
    "data_fetcher",
    [fetch_all_valid_dataframes_with_complete_data, fetch_all_valid_dataframes_l1_data],
)
def test_initialization_and_validation_pass(data_fetcher):
    result = data_fetcher()

    # Handle different lengths of return values
    if len(result) == 5:
        array_info, plant_table, _, meteo_data, _ = result
    else:
        array_info, plant_table, _, meteo_data = result

    expected_param_generator = ExpectedParametersGenerator(
        meteo_data=meteo_data, array_info=array_info, system_age=1.5
    )
    assert isinstance(expected_param_generator, ExpectedParametersGenerator)
    assert expected_param_generator.system_age == 1.5
    assert expected_param_generator.irradiance_key == "G"
    assert expected_param_generator.array_info.equals(array_info)
    assert expected_param_generator.irradiance.isnull().sum().sum() == 0
    # Confirm irradiance was extracted correctly
    assert isinstance(expected_param_generator.irradiance, pd.DataFrame)
    assert not expected_param_generator.irradiance.empty
    assert expected_param_generator.irradiance.columns.equals(
        meteo_data.xs("G", axis=1, level="curve").columns
    )

    # Fallback mode check
    if all(
        k in array_info.columns
        for k in ["panel_wattage", "modules_per_string", "number_of_strings"]
    ):
        assert expected_param_generator.use_dc_capacity is False
    else:
        assert expected_param_generator.use_dc_capacity is True

    # Intermediate cache should start empty
    assert expected_param_generator._intermediate_cache == {}

    # Array info columns validation: required keys exist and are validated
    for k in expected_param_generator.KEYS_TO_BE_VALIDATED:
        if k in array_info.columns:
            assert not array_info[k].isnull().any()
            assert (array_info[k] != 0).all()


@pytest.mark.parametrize("data_fetcher", [fetch_all_valid_dataframes_l1_data])
def test_fallback_mode_warning_logged(data_fetcher, caplog):
    result = data_fetcher()
    if len(result) == 5:
        array_info, _, _, meteo_data, _ = result
    else:
        array_info, _, _, meteo_data = result

    caplog.set_level(logging.WARNING)
    _ = ExpectedParametersGenerator(
        meteo_data=meteo_data, array_info=array_info, system_age=1.5
    )

    if not all(
        k in array_info.columns
        for k in ["panel_wattage", "modules_per_string", "number_of_strings"]
    ):
        assert "Fallback mode triggered" in caplog.text


def test_invalid_system_age():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    with pytest.raises(ValueError, match="system_age must be a non-negative."):
        ExpectedParametersGenerator(
            meteo_data=meteo_data, array_info=array_info, system_age=-2
        )


def test_missing_irradiance_key():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    invalid_irradiance_key = "INVALID"
    with pytest.raises(
        ValueError,
        match=f"Irradiance key '{invalid_irradiance_key}' not found in meteo data.",
    ):
        ExpectedParametersGenerator(
            meteo_data=meteo_data,
            array_info=array_info,
            system_age=1.2,
            irradiance_key=invalid_irradiance_key,
        )


def test_expected_power_stc_l2():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=2)
    power = generator._expected_power_stc()
    assert not power.empty and (power >= 0).all().all()


def test_expected_voltage_stc_l2():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=2)
    voltage = generator._expected_voltage_stc()
    assert not voltage.empty and voltage.isna().sum().sum() < voltage.size


def test_expected_power_stc_l1():
    array_info, _, _, meteo_data, _ = fetch_all_valid_dataframes_l1_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=2)
    power = generator._expected_power_stc()
    assert not power.empty and (power >= 0).all().all()


def test_expected_degradation_l2():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=5)
    degr = generator._expected_degradation()
    assert not degr.empty and degr.max() <= 1.0


def test_expected_energy_degradation_l1():
    array_info, _, _, meteo_data, _ = fetch_all_valid_dataframes_l1_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=2)
    energy = generator._expected_energy_noct(data_frequency_minutes=5)
    assert not energy.empty and (energy >= 0).all().all()


def test_expected_features_full_l2():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=1)
    config = {
        "NOCT": {
            "power": True,
            "power_degradation": True,
            "current": True,
            "voltage": True,
            "energy_degradation": True,
        },
        "STC": {"power": True, "current": True, "voltage": True},
    }
    result = generator.generate_expected_features(
        config=config, data_frequency_minutes=5
    )
    assert not result.empty


def test_expected_features_minimal_l1():
    array_info, _, _, meteo_data, _ = fetch_all_valid_dataframes_l1_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=1)
    config = {
        "NOCT": {
            "energy_degradation": True,
        }
    }
    result = generator.generate_expected_features(
        config=config, data_frequency_minutes=5
    )
    assert not result.empty


def test_expected_features_with_clearsky():
    array_info, _, _, meteo_data, clearsky_data = fetch_all_valid_dataframes_l1_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=1)
    config = {
        "NOCT": {
            "clearsky_energy_degradation": True,
            "power_degradation_clearsky": True,
        }
    }
    result = generator.generate_expected_features(
        config=config,
        data_frequency_minutes=5,
        clearsky_data=clearsky_data,
        clearsky_key="Gcsky",
        include_inverter_efficiency=True,
    )
    assert not result.empty


def test_expected_features_empty_config_returns_empty_df():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=1)
    result = generator.generate_expected_features(config={}, data_frequency_minutes=5)
    assert result.empty


def test_expected_features_clearsky_missing_when_required(caplog):
    array_info, _, _, meteo_data, _ = fetch_all_valid_dataframes_l1_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=1)
    config = {"NOCT": {"clearsky_energy_degradation": True}}
    result = generator.generate_expected_features(
        config=config, data_frequency_minutes=5
    )
    assert result.empty
    assert (
        "Skipping E_exp_noct_degradation_clearsky calculation because clearsky_data is not provided"
        in caplog.text
    )


def test_intermediate_cache_reuse():
    array_info, _, _, meteo_data = fetch_all_valid_dataframes_with_complete_data()
    generator = ExpectedParametersGenerator(meteo_data, array_info, system_age=2)
    _ = generator._expected_power_stc()
    assert "P_exp_stc" in generator._intermediate_cache
    cached_value = generator._intermediate_cache["P_exp_stc"]
    second_call = generator._expected_power_stc()
    assert second_call.equals(cached_value)
